<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>为VTK修复vtkOBJReader的一个segfault | Qiao</title><meta name=keywords content="VTK,C++,Visualization"><meta name=description content="Background 测试用PyTorch3D生成的Mesh时，打算用VTK对Mesh做离屏渲染生成图片，结果发现VTK的python binding和C++库都会在vtkOBJReader::Update时崩溃。由于是AI模型生成的OBJ文件，OBJ本身是有可能不太标准的，但用Blender、Open3D、trimesh测试，发现都可以加载该文件。看起来似乎VTK的vtkOBJReader实现不够健壮，遂决定调试一番。
Debug 以导致问题的OBJ文件编写复现demo，目录结构：
$ tree . . ├── assets │ ├── rand_0_diffuse.png │ ├── rand_0_normal.png │ ├── rand_0_skin.mtl │ ├── rand_0_skin.obj │ └── rand_0_spec.png ├── CMakeLists.txt └── main.cpp main.cpp：
#include <vtkOBJReader.h> int main() { vtkNew<vtkOBJReader> reader; reader->SetFileName(&#34;rand_0_skin.obj&#34;); reader->Update(); return 0; } 崩溃堆栈：
1 vtkAOSDataArrayTemplate<float>::GetTuple vtkAOSDataArrayTemplate.txx 275 0x7ffff6ee05e5 2 vtkOBJReader::RequestData vtkOBJReader.cxx 978 0x7ffff7b4c793 3 vtkPolyDataAlgorithm::ProcessRequest vtkPolyDataAlgorithm.cxx 87 0x7ffff28aaec6 4 vtkExecutive::CallAlgorithm vtkExecutive.cxx 734 0x7ffff287faf9 5 vtkDemandDrivenPipeline::ExecuteData vtkDemandDrivenPipeline.cxx 461 0x7ffff2876004 6 vtkCompositeDataPipeline::ExecuteData vtkCompositeDataPipeline."><meta name=author content="Qiao"><link rel=canonical href=https://tanjoe.github.io/posts/%E4%B8%BAvtk%E4%BF%AE%E5%A4%8Dvtkobjreader%E7%9A%84%E4%B8%80%E4%B8%AAsegfault/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"forest",themeVariables:{lineColor:"#fafafa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><meta property="og:title" content="为VTK修复vtkOBJReader的一个segfault"><meta property="og:description" content="Background 测试用PyTorch3D生成的Mesh时，打算用VTK对Mesh做离屏渲染生成图片，结果发现VTK的python binding和C++库都会在vtkOBJReader::Update时崩溃。由于是AI模型生成的OBJ文件，OBJ本身是有可能不太标准的，但用Blender、Open3D、trimesh测试，发现都可以加载该文件。看起来似乎VTK的vtkOBJReader实现不够健壮，遂决定调试一番。
Debug 以导致问题的OBJ文件编写复现demo，目录结构：
$ tree . . ├── assets │ ├── rand_0_diffuse.png │ ├── rand_0_normal.png │ ├── rand_0_skin.mtl │ ├── rand_0_skin.obj │ └── rand_0_spec.png ├── CMakeLists.txt └── main.cpp main.cpp：
#include <vtkOBJReader.h> int main() { vtkNew<vtkOBJReader> reader; reader->SetFileName(&#34;rand_0_skin.obj&#34;); reader->Update(); return 0; } 崩溃堆栈：
1 vtkAOSDataArrayTemplate<float>::GetTuple vtkAOSDataArrayTemplate.txx 275 0x7ffff6ee05e5 2 vtkOBJReader::RequestData vtkOBJReader.cxx 978 0x7ffff7b4c793 3 vtkPolyDataAlgorithm::ProcessRequest vtkPolyDataAlgorithm.cxx 87 0x7ffff28aaec6 4 vtkExecutive::CallAlgorithm vtkExecutive.cxx 734 0x7ffff287faf9 5 vtkDemandDrivenPipeline::ExecuteData vtkDemandDrivenPipeline.cxx 461 0x7ffff2876004 6 vtkCompositeDataPipeline::ExecuteData vtkCompositeDataPipeline."><meta property="og:type" content="article"><meta property="og:url" content="https://tanjoe.github.io/posts/%E4%B8%BAvtk%E4%BF%AE%E5%A4%8Dvtkobjreader%E7%9A%84%E4%B8%80%E4%B8%AAsegfault/"><meta property="og:image" content="https://tanjoe.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-18T10:28:40+00:00"><meta property="article:modified_time" content="2023-01-18T10:28:40+00:00"><meta property="og:site_name" content="Qiao"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tanjoe.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="为VTK修复vtkOBJReader的一个segfault"><meta name=twitter:description content="Background 测试用PyTorch3D生成的Mesh时，打算用VTK对Mesh做离屏渲染生成图片，结果发现VTK的python binding和C++库都会在vtkOBJReader::Update时崩溃。由于是AI模型生成的OBJ文件，OBJ本身是有可能不太标准的，但用Blender、Open3D、trimesh测试，发现都可以加载该文件。看起来似乎VTK的vtkOBJReader实现不够健壮，遂决定调试一番。
Debug 以导致问题的OBJ文件编写复现demo，目录结构：
$ tree . . ├── assets │ ├── rand_0_diffuse.png │ ├── rand_0_normal.png │ ├── rand_0_skin.mtl │ ├── rand_0_skin.obj │ └── rand_0_spec.png ├── CMakeLists.txt └── main.cpp main.cpp：
#include <vtkOBJReader.h> int main() { vtkNew<vtkOBJReader> reader; reader->SetFileName(&#34;rand_0_skin.obj&#34;); reader->Update(); return 0; } 崩溃堆栈：
1 vtkAOSDataArrayTemplate<float>::GetTuple vtkAOSDataArrayTemplate.txx 275 0x7ffff6ee05e5 2 vtkOBJReader::RequestData vtkOBJReader.cxx 978 0x7ffff7b4c793 3 vtkPolyDataAlgorithm::ProcessRequest vtkPolyDataAlgorithm.cxx 87 0x7ffff28aaec6 4 vtkExecutive::CallAlgorithm vtkExecutive.cxx 734 0x7ffff287faf9 5 vtkDemandDrivenPipeline::ExecuteData vtkDemandDrivenPipeline.cxx 461 0x7ffff2876004 6 vtkCompositeDataPipeline::ExecuteData vtkCompositeDataPipeline."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tanjoe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"为VTK修复vtkOBJReader的一个segfault","item":"https://tanjoe.github.io/posts/%E4%B8%BAvtk%E4%BF%AE%E5%A4%8Dvtkobjreader%E7%9A%84%E4%B8%80%E4%B8%AAsegfault/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"为VTK修复vtkOBJReader的一个segfault","name":"为VTK修复vtkOBJReader的一个segfault","description":"Background 测试用PyTorch3D生成的Mesh时，打算用VTK对Mesh做离屏渲染生成图片，结果发现VTK的python binding和C++库都会在vtkOBJReader::Update时崩溃。由于是AI模型生成的OBJ文件，OBJ本身是有可能不太标准的，但用Blender、Open3D、trimesh测试，发现都可以加载该文件。看起来似乎VTK的vtkOBJReader实现不够健壮，遂决定调试一番。\nDebug 以导致问题的OBJ文件编写复现demo，目录结构：\n$ tree . . ├── assets │ ├── rand_0_diffuse.png │ ├── rand_0_normal.png │ ├── rand_0_skin.mtl │ ├── rand_0_skin.obj │ └── rand_0_spec.png ├── CMakeLists.txt └── main.cpp main.cpp：\n#include \u0026lt;vtkOBJReader.h\u0026gt; int main() { vtkNew\u0026lt;vtkOBJReader\u0026gt; reader; reader-\u0026gt;SetFileName(\u0026#34;rand_0_skin.obj\u0026#34;); reader-\u0026gt;Update(); return 0; } 崩溃堆栈：\n1 vtkAOSDataArrayTemplate\u0026lt;float\u0026gt;::GetTuple vtkAOSDataArrayTemplate.txx 275 0x7ffff6ee05e5 2 vtkOBJReader::RequestData vtkOBJReader.cxx 978 0x7ffff7b4c793 3 vtkPolyDataAlgorithm::ProcessRequest vtkPolyDataAlgorithm.cxx 87 0x7ffff28aaec6 4 vtkExecutive::CallAlgorithm vtkExecutive.cxx 734 0x7ffff287faf9 5 vtkDemandDrivenPipeline::ExecuteData vtkDemandDrivenPipeline.cxx 461 0x7ffff2876004 6 vtkCompositeDataPipeline::ExecuteData vtkCompositeDataPipeline.","keywords":["VTK","C++","Visualization"],"articleBody":"Background 测试用PyTorch3D生成的Mesh时，打算用VTK对Mesh做离屏渲染生成图片，结果发现VTK的python binding和C++库都会在vtkOBJReader::Update时崩溃。由于是AI模型生成的OBJ文件，OBJ本身是有可能不太标准的，但用Blender、Open3D、trimesh测试，发现都可以加载该文件。看起来似乎VTK的vtkOBJReader实现不够健壮，遂决定调试一番。\nDebug 以导致问题的OBJ文件编写复现demo，目录结构：\n$ tree . . ├── assets │ ├── rand_0_diffuse.png │ ├── rand_0_normal.png │ ├── rand_0_skin.mtl │ ├── rand_0_skin.obj │ └── rand_0_spec.png ├── CMakeLists.txt └── main.cpp main.cpp：\n#include int main() { vtkNew\u003cvtkOBJReader\u003e reader; reader-\u003eSetFileName(\"rand_0_skin.obj\"); reader-\u003eUpdate(); return 0; } 崩溃堆栈：\n1 vtkAOSDataArrayTemplate::GetTuple vtkAOSDataArrayTemplate.txx 275 0x7ffff6ee05e5 2 vtkOBJReader::RequestData vtkOBJReader.cxx 978 0x7ffff7b4c793 3 vtkPolyDataAlgorithm::ProcessRequest vtkPolyDataAlgorithm.cxx 87 0x7ffff28aaec6 4 vtkExecutive::CallAlgorithm vtkExecutive.cxx 734 0x7ffff287faf9 5 vtkDemandDrivenPipeline::ExecuteData vtkDemandDrivenPipeline.cxx 461 0x7ffff2876004 6 vtkCompositeDataPipeline::ExecuteData vtkCompositeDataPipeline.cxx 162 0x7ffff2869321 7 vtkDemandDrivenPipeline::ProcessRequest vtkDemandDrivenPipeline.cxx 260 0x7ffff28755b1 8 vtkStreamingDemandDrivenPipeline::ProcessRequest vtkStreamingDemandDrivenPipeline.cxx 343 0x7ffff2943429 9 vtkDemandDrivenPipeline::UpdateData vtkDemandDrivenPipeline.cxx 418 0x7ffff2875de9 10 vtkStreamingDemandDrivenPipeline::Update vtkStreamingDemandDrivenPipeline.cxx 417 0x7ffff29437c4 11 vtkStreamingDemandDrivenPipeline::Update vtkStreamingDemandDrivenPipeline.cxx 380 0x7ffff294364d 12 vtkAlgorithm::Update vtkAlgorithm.cxx 1406 0x7ffff285f3b4 13 vtkAlgorithm::Update vtkAlgorithm.cxx 1400 0x7ffff285f37f 14 main main.cpp 7 0x555555555297 调试后，发现崩溃的直接原因是vtkAOSDataArrayTemplate的Buffer为null，data实际是野指针：\ntemplate \u003cclass ValueTypeT\u003e double* vtkAOSDataArrayTemplate\u003cValueTypeT\u003e::GetTuple(vtkIdType tupleIdx) { ValueTypeT* data = this-\u003eBuffer-\u003eGetBuffer() + tupleIdx * this-\u003eNumberOfComponents; double* tuple = \u0026this-\u003eLegacyTuple[0]; // See note in SetTuple about std::copy vs for loops on MSVC. for (int i = 0; i \u003c this-\u003eNumberOfComponents; ++i) { tuple[i] = static_cast\u003cdouble\u003e(data[i]); } return \u0026this-\u003eLegacyTuple[0]; } 转到vtkOBJReader::RequestData调试，发现normals从未加入过值。以纯文本方式打开该OBJ，发现确实没有任何vn（vertex normal）字段，这也就解释了为何normals为空：\nint vtkOBJReader::RequestData(vtkInformation* vtkNotUsed(request), vtkInformationVector** vtkNotUsed(inputVector), vtkInformationVector* outputVector) { // ... if (n_normal_pts \u003e 0) { new_normals-\u003eInsertNextTuple(normals-\u003eGetTuple(normal_pts[pointi])); } // ... } 但等等，为什么n_normal_pts为3而非0？从变量命名上看，该变量应该记录的是normal的数量才对。n_normal_pts获取自normal_polys：\nint vtkOBJReader::RequestData(vtkInformation* vtkNotUsed(request), vtkInformationVector** vtkNotUsed(inputVector), vtkInformationVector* outputVector) { //... tcoord_polys-\u003eGetNextCell(n_tcoord_pts, tcoord_pts); normal_polys-\u003eGetNextCell(n_normal_pts, normal_pts); //... } 进一步调试，发现normal_polys是在以下片段修改的：\nint vtkOBJReader::RequestData(vtkInformation* vtkNotUsed(request), vtkInformationVector** vtkNotUsed(inputVector), vtkInformationVector* outputVector) { //... else if (strcmp(cmd, \"f\") == 0) { // face definition, consisting of 1-based indices separated by whitespace and / polys-\u003eInsertNextCell(0); // we don't yet know how many points are to come tcoord_polys-\u003eInsertNextCell(0); normal_polys-\u003eInsertNextCell(0); int nVerts = 0, nTCoords = 0, nNormals = 0; // keep a count of how many of each there are while (everything_ok \u0026\u0026 pLine \u003c pEnd) { // find the first non-whitespace character while (isspace(*pLine) \u0026\u0026 pLine \u003c pEnd) { pLine++; } if (pLine \u003c pEnd) // there is still data left on this line { int iVert, iTCoord, iNormal; if (sscanf(pLine, \"%d/%d/%d\", \u0026iVert, \u0026iTCoord, \u0026iNormal) == 3) { if (iVert \u003c 0) { polys-\u003eInsertCellPoint(numPoints + iVert); } else { polys-\u003eInsertCellPoint(iVert - 1); } nVerts++; // Current index is relative to last texture index int iTCoordAbs = (iTCoord \u003c 0) ? numTCoords + iTCoord : iTCoord - 1; tcoord_polys-\u003eInsertCellPoint(iTCoordAbs); // Set the current texture array with the value corresponding to the // iTcoords read const auto\u0026 currentTCoord = verticesTextureList[iTCoordAbs]; auto iter = tcoords_map.find(tcoordsName); vtkFloatArray* tcArray = iter-\u003esecond; tcArray-\u003eSetTuple2(iTCoordAbs, currentTCoord.first, currentTCoord.second); nTCoords++; // Current index is relative to last normal index if (iNormal \u003c 0) { normal_polys-\u003eInsertCellPoint(numNormals + iNormal); } else { normal_polys-\u003eInsertCellPoint(iNormal - 1); } nNormals++; if (iTCoord != iVert) { tcoords_same_as_verts = false; } if (iNormal != iVert) { normals_same_as_verts = false; } } // ... } } // ... } OBJ中的f（face）字段，按 http://paulbourke.net/dataformats/obj/ 对OBJ格式的介绍，可以用reference number以索引的方式引用出现过的顶点和法线数据：\nUsing v, vt, and vn to represent geometric vertices, texture vertices, and vertex normals, the statement would read:\nf v/vt/vn v/vt/vn v/vt/vn v/vt/vn 再看OBJ文件，也的确有众多的f字段：\nusemtl material_0 vt 0.648233 0.593283 vt 0.646499 0.584196 vt 0.655584 0.585689 f 2/1/2 3/2/3 1/3/1 vt 0.406369 0.356120 vt 0.403783 0.346783 vt 0.415342 0.350329 f 5/4/5 6/5/6 4/6/4 而正如上文所言，该OBJ并没有任何vn字段，即f字段引用的顶点法线都是无效的。vtkOBJReader将引用的法线数视为已插入的法线数，这就导致了n_normal_pts非0，而normals实际没有任何数据。\nFix 原因探查清楚后，对于这类野指针问题，修复措施也很简单，加个判断即可：\n} } // copy the normal for this point across (if there is one) - if (n_normal_pts \u003e 0) + if (n_normal_pts \u003e 0 \u0026\u0026 normals-\u003eGetNumberOfTuples() \u003e 0) { new_normals-\u003eInsertNextTuple(normals-\u003eGetTuple(normal_pts[pointi])); } Merge Request 修复已合并至VTK主干：https://gitlab.kitware.com/vtk/vtk/-/merge_requests/9827?commit_id=4b7d53504bb3e786517024fe32dc5c80e7f6e2c4\n","wordCount":"530","inLanguage":"en","datePublished":"2023-01-18T10:28:40Z","dateModified":"2023-01-18T10:28:40Z","author":{"@type":"Person","name":"Qiao"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tanjoe.github.io/posts/%E4%B8%BAvtk%E4%BF%AE%E5%A4%8Dvtkobjreader%E7%9A%84%E4%B8%80%E4%B8%AAsegfault/"},"publisher":{"@type":"Organization","name":"Qiao","logo":{"@type":"ImageObject","url":"https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tanjoe.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://tanjoe.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tanjoe.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://tanjoe.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tanjoe.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tanjoe.github.io/posts/>Posts</a></div><h1 class=post-title>为VTK修复vtkOBJReader的一个segfault</h1><div class=post-meta><span title='2023-01-18 10:28:40 +0000 UTC'>2023-01-18</span>&nbsp;·&nbsp;Qiao</div></header><div class=post-content><h2 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h2><p>测试用PyTorch3D生成的Mesh时，打算用VTK对Mesh做离屏渲染生成图片，结果发现VTK的python binding和C++库都会在<code>vtkOBJReader::Update</code>时崩溃。由于是AI模型生成的OBJ文件，OBJ本身是有可能不太标准的，但用Blender、Open3D、trimesh测试，发现都可以加载该文件。看起来似乎VTK的<code>vtkOBJReader</code>实现不够健壮，遂决定调试一番。</p><h2 id=debug>Debug<a hidden class=anchor aria-hidden=true href=#debug>#</a></h2><p>以导致问题的OBJ文件编写复现demo，目录结构：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ tree .
</span></span><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>├── assets
</span></span><span class=line><span class=cl>│   ├── rand_0_diffuse.png
</span></span><span class=line><span class=cl>│   ├── rand_0_normal.png
</span></span><span class=line><span class=cl>│   ├── rand_0_skin.mtl
</span></span><span class=line><span class=cl>│   ├── rand_0_skin.obj
</span></span><span class=line><span class=cl>│   └── rand_0_spec.png
</span></span><span class=line><span class=cl>├── CMakeLists.txt
</span></span><span class=line><span class=cl>└── main.cpp
</span></span></code></pre></div><p><code>main.cpp</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vtkOBJReader.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vtkNew</span><span class=o>&lt;</span><span class=n>vtkOBJReader</span><span class=o>&gt;</span> <span class=n>reader</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>reader</span><span class=o>-&gt;</span><span class=n>SetFileName</span><span class=p>(</span><span class=s>&#34;rand_0_skin.obj&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>reader</span><span class=o>-&gt;</span><span class=n>Update</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>崩溃堆栈：</p><pre tabindex=0><code>1  vtkAOSDataArrayTemplate&lt;float&gt;::GetTuple         vtkAOSDataArrayTemplate.txx          275  0x7ffff6ee05e5 
2  vtkOBJReader::RequestData                        vtkOBJReader.cxx                     978  0x7ffff7b4c793 
3  vtkPolyDataAlgorithm::ProcessRequest             vtkPolyDataAlgorithm.cxx             87   0x7ffff28aaec6 
4  vtkExecutive::CallAlgorithm                      vtkExecutive.cxx                     734  0x7ffff287faf9 
5  vtkDemandDrivenPipeline::ExecuteData             vtkDemandDrivenPipeline.cxx          461  0x7ffff2876004 
6  vtkCompositeDataPipeline::ExecuteData            vtkCompositeDataPipeline.cxx         162  0x7ffff2869321 
7  vtkDemandDrivenPipeline::ProcessRequest          vtkDemandDrivenPipeline.cxx          260  0x7ffff28755b1 
8  vtkStreamingDemandDrivenPipeline::ProcessRequest vtkStreamingDemandDrivenPipeline.cxx 343  0x7ffff2943429 
9  vtkDemandDrivenPipeline::UpdateData              vtkDemandDrivenPipeline.cxx          418  0x7ffff2875de9 
10 vtkStreamingDemandDrivenPipeline::Update         vtkStreamingDemandDrivenPipeline.cxx 417  0x7ffff29437c4 
11 vtkStreamingDemandDrivenPipeline::Update         vtkStreamingDemandDrivenPipeline.cxx 380  0x7ffff294364d 
12 vtkAlgorithm::Update                             vtkAlgorithm.cxx                     1406 0x7ffff285f3b4 
13 vtkAlgorithm::Update                             vtkAlgorithm.cxx                     1400 0x7ffff285f37f 
14 main                                             main.cpp                             7    0x555555555297 
</code></pre><p>调试后，发现崩溃的直接原因是<code>vtkAOSDataArrayTemplate&lt;float></code>的<code>Buffer</code>为<code>null</code>，<code>data</code>实际是野指针：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ValueTypeT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>double</span><span class=o>*</span> <span class=n>vtkAOSDataArrayTemplate</span><span class=o>&lt;</span><span class=n>ValueTypeT</span><span class=o>&gt;::</span><span class=n>GetTuple</span><span class=p>(</span><span class=n>vtkIdType</span> <span class=n>tupleIdx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>ValueTypeT</span><span class=o>*</span> <span class=n>data</span> <span class=o>=</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>Buffer</span><span class=o>-&gt;</span><span class=n>GetBuffer</span><span class=p>()</span> <span class=o>+</span> <span class=n>tupleIdx</span> <span class=o>*</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>NumberOfComponents</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>double</span><span class=o>*</span> <span class=n>tuple</span> <span class=o>=</span> <span class=o>&amp;</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>LegacyTuple</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=c1>// See note in SetTuple about std::copy vs for loops on MSVC.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>NumberOfComponents</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>tuple</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>&amp;</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>LegacyTuple</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>转到<code>vtkOBJReader::RequestData</code>调试，发现<code>normals</code>从未加入过值。以纯文本方式打开该OBJ，发现确实没有任何<code>vn</code>（vertex normal）字段，这也就解释了为何<code>normals</code>为空：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>vtkOBJReader</span><span class=o>::</span><span class=n>RequestData</span><span class=p>(</span><span class=n>vtkInformation</span><span class=o>*</span> <span class=n>vtkNotUsed</span><span class=p>(</span><span class=n>request</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=n>vtkInformationVector</span><span class=o>**</span> <span class=n>vtkNotUsed</span><span class=p>(</span><span class=n>inputVector</span><span class=p>),</span> <span class=n>vtkInformationVector</span><span class=o>*</span> <span class=n>outputVector</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>n_normal_pts</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>new_normals</span><span class=o>-&gt;</span><span class=n>InsertNextTuple</span><span class=p>(</span><span class=n>normals</span><span class=o>-&gt;</span><span class=n>GetTuple</span><span class=p>(</span><span class=n>normal_pts</span><span class=p>[</span><span class=n>pointi</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>但等等，为什么<code>n_normal_pts</code>为3而非0？从变量命名上看，该变量应该记录的是normal的数量才对。<code>n_normal_pts</code>获取自<code>normal_polys</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>vtkOBJReader</span><span class=o>::</span><span class=n>RequestData</span><span class=p>(</span><span class=n>vtkInformation</span><span class=o>*</span> <span class=n>vtkNotUsed</span><span class=p>(</span><span class=n>request</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=n>vtkInformationVector</span><span class=o>**</span> <span class=n>vtkNotUsed</span><span class=p>(</span><span class=n>inputVector</span><span class=p>),</span> <span class=n>vtkInformationVector</span><span class=o>*</span> <span class=n>outputVector</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>tcoord_polys</span><span class=o>-&gt;</span><span class=n>GetNextCell</span><span class=p>(</span><span class=n>n_tcoord_pts</span><span class=p>,</span> <span class=n>tcoord_pts</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>normal_polys</span><span class=o>-&gt;</span><span class=n>GetNextCell</span><span class=p>(</span><span class=n>n_normal_pts</span><span class=p>,</span> <span class=n>normal_pts</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>进一步调试，发现<code>normal_polys</code>是在以下片段修改的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>vtkOBJReader</span><span class=o>::</span><span class=n>RequestData</span><span class=p>(</span><span class=n>vtkInformation</span><span class=o>*</span> <span class=n>vtkNotUsed</span><span class=p>(</span><span class=n>request</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=n>vtkInformationVector</span><span class=o>**</span> <span class=n>vtkNotUsed</span><span class=p>(</span><span class=n>inputVector</span><span class=p>),</span> <span class=n>vtkInformationVector</span><span class=o>*</span> <span class=n>outputVector</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>strcmp</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=s>&#34;f&#34;</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// face definition, consisting of 1-based indices separated by whitespace and /
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>polys</span><span class=o>-&gt;</span><span class=n>InsertNextCell</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=c1>// we don&#39;t yet know how many points are to come
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>tcoord_polys</span><span class=o>-&gt;</span><span class=n>InsertNextCell</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>normal_polys</span><span class=o>-&gt;</span><span class=n>InsertNextCell</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>nVerts</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>nTCoords</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>nNormals</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// keep a count of how many of each there are
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>everything_ok</span> <span class=o>&amp;&amp;</span> <span class=n>pLine</span> <span class=o>&lt;</span> <span class=n>pEnd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// find the first non-whitespace character
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>while</span> <span class=p>(</span><span class=n>isspace</span><span class=p>(</span><span class=o>*</span><span class=n>pLine</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>pLine</span> <span class=o>&lt;</span> <span class=n>pEnd</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>pLine</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>pLine</span> <span class=o>&lt;</span> <span class=n>pEnd</span><span class=p>)</span> <span class=c1>// there is still data left on this line
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>int</span> <span class=n>iVert</span><span class=p>,</span> <span class=n>iTCoord</span><span class=p>,</span> <span class=n>iNormal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>sscanf</span><span class=p>(</span><span class=n>pLine</span><span class=p>,</span> <span class=s>&#34;%d/%d/%d&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>iVert</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>iTCoord</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>iNormal</span><span class=p>)</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=p>(</span><span class=n>iVert</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>polys</span><span class=o>-&gt;</span><span class=n>InsertCellPoint</span><span class=p>(</span><span class=n>numPoints</span> <span class=o>+</span> <span class=n>iVert</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=k>else</span>
</span></span><span class=line><span class=cl>                    <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>polys</span><span class=o>-&gt;</span><span class=n>InsertCellPoint</span><span class=p>(</span><span class=n>iVert</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=n>nVerts</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                    <span class=c1>// Current index is relative to last texture index
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=kt>int</span> <span class=n>iTCoordAbs</span> <span class=o>=</span> <span class=p>(</span><span class=n>iTCoord</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=o>?</span> <span class=n>numTCoords</span> <span class=o>+</span> <span class=nl>iTCoord</span> <span class=p>:</span> <span class=n>iTCoord</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>tcoord_polys</span><span class=o>-&gt;</span><span class=n>InsertCellPoint</span><span class=p>(</span><span class=n>iTCoordAbs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                    <span class=c1>// Set the current texture array with the value corresponding to the
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// iTcoords read
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=n>currentTCoord</span> <span class=o>=</span> <span class=n>verticesTextureList</span><span class=p>[</span><span class=n>iTCoordAbs</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                    <span class=k>auto</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>tcoords_map</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>tcoordsName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>vtkFloatArray</span><span class=o>*</span> <span class=n>tcArray</span> <span class=o>=</span> <span class=n>iter</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>tcArray</span><span class=o>-&gt;</span><span class=n>SetTuple2</span><span class=p>(</span><span class=n>iTCoordAbs</span><span class=p>,</span> <span class=n>currentTCoord</span><span class=p>.</span><span class=n>first</span><span class=p>,</span> <span class=n>currentTCoord</span><span class=p>.</span><span class=n>second</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                    <span class=n>nTCoords</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                    <span class=c1>// Current index is relative to last normal index
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>if</span> <span class=p>(</span><span class=n>iNormal</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>normal_polys</span><span class=o>-&gt;</span><span class=n>InsertCellPoint</span><span class=p>(</span><span class=n>numNormals</span> <span class=o>+</span> <span class=n>iNormal</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=k>else</span>
</span></span><span class=line><span class=cl>                    <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>normal_polys</span><span class=o>-&gt;</span><span class=n>InsertCellPoint</span><span class=p>(</span><span class=n>iNormal</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=n>nNormals</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=p>(</span><span class=n>iTCoord</span> <span class=o>!=</span> <span class=n>iVert</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>tcoords_same_as_verts</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=p>(</span><span class=n>iNormal</span> <span class=o>!=</span> <span class=n>iVert</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>normals_same_as_verts</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>OBJ中的<code>f</code>（face）字段，按 <a href=http://paulbourke.net/dataformats/obj/>http://paulbourke.net/dataformats/obj/</a> 对OBJ格式的介绍，可以用reference number以索引的方式引用出现过的顶点和法线数据：</p><blockquote><p>Using v, vt, and vn to represent geometric vertices, texture vertices,
and vertex normals, the statement would read:</p><pre><code>f v/vt/vn v/vt/vn v/vt/vn v/vt/vn
</code></pre></blockquote><p>再看OBJ文件，也的确有众多的<code>f</code>字段：</p><pre tabindex=0><code>usemtl material_0
vt 0.648233 0.593283
vt 0.646499 0.584196
vt 0.655584 0.585689
f 2/1/2 3/2/3 1/3/1
vt 0.406369 0.356120
vt 0.403783 0.346783
vt 0.415342 0.350329
f 5/4/5 6/5/6 4/6/4
</code></pre><p>而正如上文所言，该OBJ并没有任何<code>vn</code>字段，即<code>f</code>字段引用的顶点法线都是无效的。<code>vtkOBJReader</code>将引用的法线数视为已插入的法线数，这就导致了<code>n_normal_pts</code>非0，而<code>normals</code>实际没有任何数据。</p><h2 id=fix>Fix<a hidden class=anchor aria-hidden=true href=#fix>#</a></h2><p>原因探查清楚后，对于这类野指针问题，修复措施也很简单，加个判断即可：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl>
</span></span><span class=line><span class=cl>               }
</span></span><span class=line><span class=cl>             }
</span></span><span class=line><span class=cl>             // copy the normal for this point across (if there is one)
</span></span><span class=line><span class=cl><span class=gd>-            if (n_normal_pts &gt; 0)
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+            if (n_normal_pts &gt; 0 &amp;&amp; normals-&gt;GetNumberOfTuples() &gt; 0)
</span></span></span><span class=line><span class=cl><span class=gi></span>             {
</span></span><span class=line><span class=cl>               new_normals-&gt;InsertNextTuple(normals-&gt;GetTuple(normal_pts[pointi]));
</span></span><span class=line><span class=cl>             }
</span></span></code></pre></div><h2 id=merge-request>Merge Request<a hidden class=anchor aria-hidden=true href=#merge-request>#</a></h2><p>修复已合并至VTK主干：<a href="https://gitlab.kitware.com/vtk/vtk/-/merge_requests/9827?commit_id=4b7d53504bb3e786517024fe32dc5c80e7f6e2c4">https://gitlab.kitware.com/vtk/vtk/-/merge_requests/9827?commit_id=4b7d53504bb3e786517024fe32dc5c80e7f6e2c4</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tanjoe.github.io/tags/vtk/>VTK</a></li><li><a href=https://tanjoe.github.io/tags/c++/>c++</a></li><li><a href=https://tanjoe.github.io/tags/visualization/>Visualization</a></li></ul><nav class=paginav><a class=prev href=https://tanjoe.github.io/posts/ubuntu-18.04%E4%B8%8A%E5%88%87%E6%8D%A2%E9%AB%98%E7%89%88%E6%9C%ACgcc%E5%B7%A5%E5%85%B7%E9%93%BE/><span class=title>« Prev</span><br><span>Ubuntu 18.04上切换高版本GCC工具链</span></a>
<a class=next href=https://tanjoe.github.io/posts/%E8%A7%A3%E5%86%B3%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%90%E8%A1%8Cconda%E7%9A%84glibcxx%E9%97%AE%E9%A2%98/><span class=title>Next »</span><br><span>解决容器内运行conda的GLIBCXX问题</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://tanjoe.github.io/>Qiao</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>