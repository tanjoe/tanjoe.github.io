<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>从Hexo到Hugo | Qiao</title><meta name=keywords content="Hexo,Hugo,Blog,CI/CD,折腾"><meta name=description content="从Hexo到Hugo 背景 促使我从WordPress搬迁到Hexo，再决定从Hexo搬迁到Hugo的动机是：想尽可能简化写博客的流程，减少除文章撰写以外一切无关事务的精力消耗。
这一追求源于我对自身的观察。一天的精力里往往绝大部分都投入在工作之上，在闲暇中再挤出时间投入写作对意志力是个考验。以往使用WordPress时，一旦VPS的访问速度不佳，那登录后台、打开编辑器、调整样式过程中等待耗费的时间，就足以将不多的意志力消磨干净。
后续切到Hexo+Github Pages后，不得不说，这让博客的发布顺畅不少，不再需要登录后台，几乎不需要考虑排版，迁移站点时也不再有数据库的顾虑。唯一的麻烦是，每次修改文件后，需要调用Hexo CLI重新生成站点并推送到Github Pages仓库。这也意味着本地总得准备一份Node.js环境。思考一番后，前面通过使用Github Actions部署Hexo把生成和部署也自动化了，只需要写文章并推送即可。
这么愉快地用了些时日，但在和Obsidian的配合使用中，又发现了新的矛盾：
Hexo如果需要用相对路径引用图片，图片应置于文章同名的文件夹下。而在Obsidian中，我所采取的方式是图片集中放置于media目录下 笔记现在总是用Obsidian创建，但需要为Hexo复制一份需要发布的文章及资源，而重复总是不利于维护的 如果将Hexo仓库置于Obsidian Vault中，再将需要发布的文章直接放到Hexo仓库的posts目录下，虽然不用复制文章，但Obsidian Vault中会带入Hexo/Node.js相关的文件。这些文件和笔记无关，在整理笔记时无异于噪音 这些问题都可以通过修改笔记来迁就Hexo，但这就是前文所说的，文章撰写以外的事务。我现在相信：应当让博客工具迁就写作习惯，而不是调整写作习惯来适应工具。
方法 为解决以上矛盾，想到的方法是：
在Vault中新建一个文件夹（这里记作Publish），在其中初始化Git仓库，存放供发布的文章 新建一个静态站点文件夹，同样初始话Git仓库，Publish仓库作为Git子模块加入其中 静态站点生成器应支持相对路径，且对文件夹的名称无要求 这样Obsidian Vault中只需要存放笔记，至于静态站点生成相关的内容则不再其中。为了方便博客发布的流程，还应该做到：
推送静态站点仓库时，应自动生成和部署站点，免去本地生成站点的麻烦 在Publish仓库中推送时，应自动更新静态站点仓库，让子模块引用Publish仓库的最新提交，免去需要在两个仓库中提交和推送的麻烦 做到这些后，应当可以：
不需要为了发布而改变记录笔记的方式 只维护一份需发布的资源 只需推送文章到远端，站点即能自动更新，本地不需要配置环境或手动生成站点 本想看看有没有办法让Hexo支持任意文件夹名的相对路径，但惊讶地发现并没有轻松的方式实现（我原以为这是非常常见的需求）。Gatsby/Jekyll/Hugo等一众工具也不原生支持此需求，这似乎与文件名到URL的映射有关。不过 GitHub - zoni/obsidian-export: Rust library and CLI to export an Obsidian vault to regular Markdown 提供了一个解决方式，遂决定切换到Hugo。
实施 支持相对路径 在Obsidian Vault中新建一个文件夹（这里记为Publish），在其中初始化Git仓库，存放供发布的文章。在Github上创建远端仓库并推送 用hugo new site命令创建站点文件夹（这里记为Site），同样初始化Git仓库。在Github上创建xxx.github.io名称的仓库并推送 与Hexo一样，Hugo同样支持主题，这里选用了PaperMod | Hugo Themes 在主题的layouts/_default/_markup/render-image.html中，加入以下代码片段以支持相对路径引用图片： {{- $url := urls.Parse .Destination -}} {{- $scheme := $url.Scheme -}} <a href=&#34; {{- if eq $scheme &#34;&#34; -}} {{- if strings."><meta name=author content="Qiao"><link rel=canonical href=https://tanjoe.github.io/posts/%E4%BB%8Ehexo%E5%88%B0hugo/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"forest",themeVariables:{lineColor:"#fafafa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><meta property="og:title" content="从Hexo到Hugo"><meta property="og:description" content="从Hexo到Hugo 背景 促使我从WordPress搬迁到Hexo，再决定从Hexo搬迁到Hugo的动机是：想尽可能简化写博客的流程，减少除文章撰写以外一切无关事务的精力消耗。
这一追求源于我对自身的观察。一天的精力里往往绝大部分都投入在工作之上，在闲暇中再挤出时间投入写作对意志力是个考验。以往使用WordPress时，一旦VPS的访问速度不佳，那登录后台、打开编辑器、调整样式过程中等待耗费的时间，就足以将不多的意志力消磨干净。
后续切到Hexo+Github Pages后，不得不说，这让博客的发布顺畅不少，不再需要登录后台，几乎不需要考虑排版，迁移站点时也不再有数据库的顾虑。唯一的麻烦是，每次修改文件后，需要调用Hexo CLI重新生成站点并推送到Github Pages仓库。这也意味着本地总得准备一份Node.js环境。思考一番后，前面通过使用Github Actions部署Hexo把生成和部署也自动化了，只需要写文章并推送即可。
这么愉快地用了些时日，但在和Obsidian的配合使用中，又发现了新的矛盾：
Hexo如果需要用相对路径引用图片，图片应置于文章同名的文件夹下。而在Obsidian中，我所采取的方式是图片集中放置于media目录下 笔记现在总是用Obsidian创建，但需要为Hexo复制一份需要发布的文章及资源，而重复总是不利于维护的 如果将Hexo仓库置于Obsidian Vault中，再将需要发布的文章直接放到Hexo仓库的posts目录下，虽然不用复制文章，但Obsidian Vault中会带入Hexo/Node.js相关的文件。这些文件和笔记无关，在整理笔记时无异于噪音 这些问题都可以通过修改笔记来迁就Hexo，但这就是前文所说的，文章撰写以外的事务。我现在相信：应当让博客工具迁就写作习惯，而不是调整写作习惯来适应工具。
方法 为解决以上矛盾，想到的方法是：
在Vault中新建一个文件夹（这里记作Publish），在其中初始化Git仓库，存放供发布的文章 新建一个静态站点文件夹，同样初始话Git仓库，Publish仓库作为Git子模块加入其中 静态站点生成器应支持相对路径，且对文件夹的名称无要求 这样Obsidian Vault中只需要存放笔记，至于静态站点生成相关的内容则不再其中。为了方便博客发布的流程，还应该做到：
推送静态站点仓库时，应自动生成和部署站点，免去本地生成站点的麻烦 在Publish仓库中推送时，应自动更新静态站点仓库，让子模块引用Publish仓库的最新提交，免去需要在两个仓库中提交和推送的麻烦 做到这些后，应当可以：
不需要为了发布而改变记录笔记的方式 只维护一份需发布的资源 只需推送文章到远端，站点即能自动更新，本地不需要配置环境或手动生成站点 本想看看有没有办法让Hexo支持任意文件夹名的相对路径，但惊讶地发现并没有轻松的方式实现（我原以为这是非常常见的需求）。Gatsby/Jekyll/Hugo等一众工具也不原生支持此需求，这似乎与文件名到URL的映射有关。不过 GitHub - zoni/obsidian-export: Rust library and CLI to export an Obsidian vault to regular Markdown 提供了一个解决方式，遂决定切换到Hugo。
实施 支持相对路径 在Obsidian Vault中新建一个文件夹（这里记为Publish），在其中初始化Git仓库，存放供发布的文章。在Github上创建远端仓库并推送 用hugo new site命令创建站点文件夹（这里记为Site），同样初始化Git仓库。在Github上创建xxx.github.io名称的仓库并推送 与Hexo一样，Hugo同样支持主题，这里选用了PaperMod | Hugo Themes 在主题的layouts/_default/_markup/render-image.html中，加入以下代码片段以支持相对路径引用图片： {{- $url := urls.Parse .Destination -}} {{- $scheme := $url.Scheme -}} <a href=&#34; {{- if eq $scheme &#34;&#34; -}} {{- if strings."><meta property="og:type" content="article"><meta property="og:url" content="https://tanjoe.github.io/posts/%E4%BB%8Ehexo%E5%88%B0hugo/"><meta property="og:image" content="https://tanjoe.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-06T09:43:51+00:00"><meta property="article:modified_time" content="2023-04-06T09:43:51+00:00"><meta property="og:site_name" content="Qiao"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tanjoe.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="从Hexo到Hugo"><meta name=twitter:description content="从Hexo到Hugo 背景 促使我从WordPress搬迁到Hexo，再决定从Hexo搬迁到Hugo的动机是：想尽可能简化写博客的流程，减少除文章撰写以外一切无关事务的精力消耗。
这一追求源于我对自身的观察。一天的精力里往往绝大部分都投入在工作之上，在闲暇中再挤出时间投入写作对意志力是个考验。以往使用WordPress时，一旦VPS的访问速度不佳，那登录后台、打开编辑器、调整样式过程中等待耗费的时间，就足以将不多的意志力消磨干净。
后续切到Hexo+Github Pages后，不得不说，这让博客的发布顺畅不少，不再需要登录后台，几乎不需要考虑排版，迁移站点时也不再有数据库的顾虑。唯一的麻烦是，每次修改文件后，需要调用Hexo CLI重新生成站点并推送到Github Pages仓库。这也意味着本地总得准备一份Node.js环境。思考一番后，前面通过使用Github Actions部署Hexo把生成和部署也自动化了，只需要写文章并推送即可。
这么愉快地用了些时日，但在和Obsidian的配合使用中，又发现了新的矛盾：
Hexo如果需要用相对路径引用图片，图片应置于文章同名的文件夹下。而在Obsidian中，我所采取的方式是图片集中放置于media目录下 笔记现在总是用Obsidian创建，但需要为Hexo复制一份需要发布的文章及资源，而重复总是不利于维护的 如果将Hexo仓库置于Obsidian Vault中，再将需要发布的文章直接放到Hexo仓库的posts目录下，虽然不用复制文章，但Obsidian Vault中会带入Hexo/Node.js相关的文件。这些文件和笔记无关，在整理笔记时无异于噪音 这些问题都可以通过修改笔记来迁就Hexo，但这就是前文所说的，文章撰写以外的事务。我现在相信：应当让博客工具迁就写作习惯，而不是调整写作习惯来适应工具。
方法 为解决以上矛盾，想到的方法是：
在Vault中新建一个文件夹（这里记作Publish），在其中初始化Git仓库，存放供发布的文章 新建一个静态站点文件夹，同样初始话Git仓库，Publish仓库作为Git子模块加入其中 静态站点生成器应支持相对路径，且对文件夹的名称无要求 这样Obsidian Vault中只需要存放笔记，至于静态站点生成相关的内容则不再其中。为了方便博客发布的流程，还应该做到：
推送静态站点仓库时，应自动生成和部署站点，免去本地生成站点的麻烦 在Publish仓库中推送时，应自动更新静态站点仓库，让子模块引用Publish仓库的最新提交，免去需要在两个仓库中提交和推送的麻烦 做到这些后，应当可以：
不需要为了发布而改变记录笔记的方式 只维护一份需发布的资源 只需推送文章到远端，站点即能自动更新，本地不需要配置环境或手动生成站点 本想看看有没有办法让Hexo支持任意文件夹名的相对路径，但惊讶地发现并没有轻松的方式实现（我原以为这是非常常见的需求）。Gatsby/Jekyll/Hugo等一众工具也不原生支持此需求，这似乎与文件名到URL的映射有关。不过 GitHub - zoni/obsidian-export: Rust library and CLI to export an Obsidian vault to regular Markdown 提供了一个解决方式，遂决定切换到Hugo。
实施 支持相对路径 在Obsidian Vault中新建一个文件夹（这里记为Publish），在其中初始化Git仓库，存放供发布的文章。在Github上创建远端仓库并推送 用hugo new site命令创建站点文件夹（这里记为Site），同样初始化Git仓库。在Github上创建xxx.github.io名称的仓库并推送 与Hexo一样，Hugo同样支持主题，这里选用了PaperMod | Hugo Themes 在主题的layouts/_default/_markup/render-image.html中，加入以下代码片段以支持相对路径引用图片： {{- $url := urls.Parse .Destination -}} {{- $scheme := $url.Scheme -}} <a href=&#34; {{- if eq $scheme &#34;&#34; -}} {{- if strings."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tanjoe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"从Hexo到Hugo","item":"https://tanjoe.github.io/posts/%E4%BB%8Ehexo%E5%88%B0hugo/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"从Hexo到Hugo","name":"从Hexo到Hugo","description":"从Hexo到Hugo 背景 促使我从WordPress搬迁到Hexo，再决定从Hexo搬迁到Hugo的动机是：想尽可能简化写博客的流程，减少除文章撰写以外一切无关事务的精力消耗。\n这一追求源于我对自身的观察。一天的精力里往往绝大部分都投入在工作之上，在闲暇中再挤出时间投入写作对意志力是个考验。以往使用WordPress时，一旦VPS的访问速度不佳，那登录后台、打开编辑器、调整样式过程中等待耗费的时间，就足以将不多的意志力消磨干净。\n后续切到Hexo+Github Pages后，不得不说，这让博客的发布顺畅不少，不再需要登录后台，几乎不需要考虑排版，迁移站点时也不再有数据库的顾虑。唯一的麻烦是，每次修改文件后，需要调用Hexo CLI重新生成站点并推送到Github Pages仓库。这也意味着本地总得准备一份Node.js环境。思考一番后，前面通过使用Github Actions部署Hexo把生成和部署也自动化了，只需要写文章并推送即可。\n这么愉快地用了些时日，但在和Obsidian的配合使用中，又发现了新的矛盾：\nHexo如果需要用相对路径引用图片，图片应置于文章同名的文件夹下。而在Obsidian中，我所采取的方式是图片集中放置于media目录下 笔记现在总是用Obsidian创建，但需要为Hexo复制一份需要发布的文章及资源，而重复总是不利于维护的 如果将Hexo仓库置于Obsidian Vault中，再将需要发布的文章直接放到Hexo仓库的posts目录下，虽然不用复制文章，但Obsidian Vault中会带入Hexo/Node.js相关的文件。这些文件和笔记无关，在整理笔记时无异于噪音 这些问题都可以通过修改笔记来迁就Hexo，但这就是前文所说的，文章撰写以外的事务。我现在相信：应当让博客工具迁就写作习惯，而不是调整写作习惯来适应工具。\n方法 为解决以上矛盾，想到的方法是：\n在Vault中新建一个文件夹（这里记作Publish），在其中初始化Git仓库，存放供发布的文章 新建一个静态站点文件夹，同样初始话Git仓库，Publish仓库作为Git子模块加入其中 静态站点生成器应支持相对路径，且对文件夹的名称无要求 这样Obsidian Vault中只需要存放笔记，至于静态站点生成相关的内容则不再其中。为了方便博客发布的流程，还应该做到：\n推送静态站点仓库时，应自动生成和部署站点，免去本地生成站点的麻烦 在Publish仓库中推送时，应自动更新静态站点仓库，让子模块引用Publish仓库的最新提交，免去需要在两个仓库中提交和推送的麻烦 做到这些后，应当可以：\n不需要为了发布而改变记录笔记的方式 只维护一份需发布的资源 只需推送文章到远端，站点即能自动更新，本地不需要配置环境或手动生成站点 本想看看有没有办法让Hexo支持任意文件夹名的相对路径，但惊讶地发现并没有轻松的方式实现（我原以为这是非常常见的需求）。Gatsby/Jekyll/Hugo等一众工具也不原生支持此需求，这似乎与文件名到URL的映射有关。不过 GitHub - zoni/obsidian-export: Rust library and CLI to export an Obsidian vault to regular Markdown 提供了一个解决方式，遂决定切换到Hugo。\n实施 支持相对路径 在Obsidian Vault中新建一个文件夹（这里记为Publish），在其中初始化Git仓库，存放供发布的文章。在Github上创建远端仓库并推送 用hugo new site命令创建站点文件夹（这里记为Site），同样初始化Git仓库。在Github上创建xxx.github.io名称的仓库并推送 与Hexo一样，Hugo同样支持主题，这里选用了PaperMod | Hugo Themes 在主题的layouts/_default/_markup/render-image.html中，加入以下代码片段以支持相对路径引用图片： {{- $url := urls.Parse .Destination -}} {{- $scheme := $url.Scheme -}} \u0026lt;a href=\u0026#34; {{- if eq $scheme \u0026#34;\u0026#34; -}} {{- if strings.","keywords":["Hexo","Hugo","Blog","CI/CD","折腾"],"articleBody":"从Hexo到Hugo 背景 促使我从WordPress搬迁到Hexo，再决定从Hexo搬迁到Hugo的动机是：想尽可能简化写博客的流程，减少除文章撰写以外一切无关事务的精力消耗。\n这一追求源于我对自身的观察。一天的精力里往往绝大部分都投入在工作之上，在闲暇中再挤出时间投入写作对意志力是个考验。以往使用WordPress时，一旦VPS的访问速度不佳，那登录后台、打开编辑器、调整样式过程中等待耗费的时间，就足以将不多的意志力消磨干净。\n后续切到Hexo+Github Pages后，不得不说，这让博客的发布顺畅不少，不再需要登录后台，几乎不需要考虑排版，迁移站点时也不再有数据库的顾虑。唯一的麻烦是，每次修改文件后，需要调用Hexo CLI重新生成站点并推送到Github Pages仓库。这也意味着本地总得准备一份Node.js环境。思考一番后，前面通过使用Github Actions部署Hexo把生成和部署也自动化了，只需要写文章并推送即可。\n这么愉快地用了些时日，但在和Obsidian的配合使用中，又发现了新的矛盾：\nHexo如果需要用相对路径引用图片，图片应置于文章同名的文件夹下。而在Obsidian中，我所采取的方式是图片集中放置于media目录下 笔记现在总是用Obsidian创建，但需要为Hexo复制一份需要发布的文章及资源，而重复总是不利于维护的 如果将Hexo仓库置于Obsidian Vault中，再将需要发布的文章直接放到Hexo仓库的posts目录下，虽然不用复制文章，但Obsidian Vault中会带入Hexo/Node.js相关的文件。这些文件和笔记无关，在整理笔记时无异于噪音 这些问题都可以通过修改笔记来迁就Hexo，但这就是前文所说的，文章撰写以外的事务。我现在相信：应当让博客工具迁就写作习惯，而不是调整写作习惯来适应工具。\n方法 为解决以上矛盾，想到的方法是：\n在Vault中新建一个文件夹（这里记作Publish），在其中初始化Git仓库，存放供发布的文章 新建一个静态站点文件夹，同样初始话Git仓库，Publish仓库作为Git子模块加入其中 静态站点生成器应支持相对路径，且对文件夹的名称无要求 这样Obsidian Vault中只需要存放笔记，至于静态站点生成相关的内容则不再其中。为了方便博客发布的流程，还应该做到：\n推送静态站点仓库时，应自动生成和部署站点，免去本地生成站点的麻烦 在Publish仓库中推送时，应自动更新静态站点仓库，让子模块引用Publish仓库的最新提交，免去需要在两个仓库中提交和推送的麻烦 做到这些后，应当可以：\n不需要为了发布而改变记录笔记的方式 只维护一份需发布的资源 只需推送文章到远端，站点即能自动更新，本地不需要配置环境或手动生成站点 本想看看有没有办法让Hexo支持任意文件夹名的相对路径，但惊讶地发现并没有轻松的方式实现（我原以为这是非常常见的需求）。Gatsby/Jekyll/Hugo等一众工具也不原生支持此需求，这似乎与文件名到URL的映射有关。不过 GitHub - zoni/obsidian-export: Rust library and CLI to export an Obsidian vault to regular Markdown 提供了一个解决方式，遂决定切换到Hugo。\n实施 支持相对路径 在Obsidian Vault中新建一个文件夹（这里记为Publish），在其中初始化Git仓库，存放供发布的文章。在Github上创建远端仓库并推送 用hugo new site命令创建站点文件夹（这里记为Site），同样初始化Git仓库。在Github上创建xxx.github.io名称的仓库并推送 与Hexo一样，Hugo同样支持主题，这里选用了PaperMod | Hugo Themes 在主题的layouts/_default/_markup/render-image.html中，加入以下代码片段以支持相对路径引用图片： {{- $url := urls.Parse .Destination -}} {{- $scheme := $url.Scheme -}} \u003ca href=\" {{- if eq $scheme \"\" -}} {{- if strings.HasSuffix $url.Path \".md\" -}} {{- relref .Page .Destination | safeURL -}} {{- else -}} {{- .Destination | safeURL -}} {{- end -}} {{- else -}} {{- .Destination | safeURL -}} {{- end -}}\" {{- with .Title }} title=\"{{ . | safeHTML }}\"{{- end -}}\u003e {{- .Text | safeHTML -}} \u003c/a\u003e {{- /* whitespace stripped here to avoid trailing newline in rendered result caused by file EOL */ -}} 运行hugo server -D，在本地搭建站点服务器，发现站点图片显示正常 CI/CD配置 现在考虑站点生成和部署的CI流程。\nDeploy key与Token 为了让CI机器能访问Github上的仓库，需要创建Personal access tokens或仓库的Depoly keys。Github的Personal access tokesn现在又分Fine-grained tokens和Classic tokens，前者可以指定token到仓库细粒度的权限；至于Deploy keys，原本就是控制单个仓库的读写权限的，在使用Github Actions部署Hexo有所提及。\nSite仓库需要访问Publish仓库。由于之前创建过一对SSH秘钥作为Deploy keys，这里不妨复用。在Publish仓库界面，点击Settings -\u003e Deploy keys -\u003e Add deploy key，填入任意title，value则是公钥的内容。Site不需要也不应该写入Publish，故不勾选Allow Write Access。\n为了方便，希望在Publish仓库中有推送时，Site仓库能自动关联Publish的最新提交。这需要Publish仓库能访问Site，通知有新的提交到来。\n点击头像 -\u003e Settings -\u003e Developer Settings -\u003e Personal access tokens -\u003e Fine-grained tokens -\u003e Generate new token，创建一个访问Site的Token，注意Contents权限为Read and write.\n复制Token的值，在Publish仓库界面，点击Settings -\u003e Secrets and variables -\u003e Actions -\u003e New repository secret，Name设置为PAT（下文的Github Actions配置会用Name索引到此secret），Value则填入Token的值。\n在Site仓库中，点击Settings -\u003e Secrets -\u003e Actions -\u003e New repository secret，Name设置为BLOG_REPO_DEPLOY_PRIVATE_KEY，Value则填入私钥的内容。\n创建配置 在Publish仓库中，新建.github/workflows/trigger_hugo.yml：\nname: trigger github pages build on: push: branches: - master jobs: build: runs-on: ubuntu-latest steps: - name: Dispatch event uses: peter-evans/repository-dispatch@v2 with: token: ${{ secrets.PAT }} repository: tanjoe/tanjoe.github.io event-type: posts-push 每当向Publish仓库master分支推送时，repository-dispatch 就会向Site仓库发送posts-push类型的事件。\n在Site仓库中，新建.github/workflows/update_posts.yml：\nname: Update posts in submodule on: repository_dispatch: types: [posts-push] # Allows you to run this workflow manually from the Actions tab or through HTTP API workflow_dispatch: jobs: sync: name: Sync submodule runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: ssh-key: ${{ secrets.BLOG_REPO_DEPLOY_PRIVATE_KEY }} submodules: true lfs: true # Update references - name: Git Sumbodule Update run: | git pull --recurse-submodules git submodule update --remote --recursive - name: Commit update run: | git config --global user.name 'Git bot' git config --global user.email 'bot@noreply.github.com' git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }} git commit -am \"Auto updated submodule references\" \u0026\u0026 git push || echo \"No changes to commit\" 每当收到posts-push的事件，或Action被手动触发时，此Action会拉取子模组，在主仓库自动创建新提交并推送。\n在Site仓库中，再创建.github/workflows/hugo_deploy.yml：\nname: pages-auto-build-deploy on: push: branches: - master workflow_run: workflows: [\"Update posts in submodule\"] types: - completed jobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Sync repo uses: actions/checkout@v2 with: submodules: true ssh-key: ${{ secrets.BLOG_REPO_DEPLOY_PRIVATE_KEY }} lfs: true - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' extended: true - name: Build Hugo run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public commit_message: ${{ github.event.head_commit.message }} 这样每当master分支有新的推送，或名为Update posts in submodule的workflow执行完成时（也就是update_posts.yml对应的workflow），执行build-and-deploy。先通过ssh-key拉取子模块，也就是Publish仓库（以及模板项目仓库），使用 Hugo setup 生成站点，使用 GitHub Pages action 将目录下的./public推送到仓库的gh-pages分支。\nupdate_posts.yml的Action执行时本身就会往master分支推送，为什么还要单独指定workflow_run的部分呢？\n原因在Triggering a workflow - GitHub Docs有所解释：\nWhen you use the repository’s GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN, with the exception of workflow_dispatch and repository_dispatch, will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository’s GITHUB_TOKEN, a new workflow will not run even when the repository contains a workflow configured to run when push events occur.\n即用GITHUB_TOKEN触发的任务默认不会执行，以免无意间创建递归的任务。故这里要用workflow_run显示指定此Action可以被另一个Action触发。\n最后，Github Pages的默认部署分支是master，而master分支现在存放的是Hugo项目的文件，静态站点的内容在gh-pages分支。故要在Site仓库页面的Settings -\u003e Pages -\u003e Build and deployment中，指定gh-pages分支作为部署分支。\n大功告成！现在在Publish仓库中添加文章并推送，站点就会自动生成并部署了。\n参考 使用Github Actions部署Hexo 利用GitHub Action实现Hugo博客在GitHub Pages自动部署 - 飞狐的部落格 GitHub - peter-evans/repository-dispatch: A GitHub action to create a repository dispatch event Triggering by other repository · community · Discussion #26323 · GitHub git - Using GitHub Actions to automatically update the repo’s submodules - Stack Overflow github actions - Triggering a new workflow from another workflow? - Stack Overflow ","wordCount":"586","inLanguage":"en","datePublished":"2023-04-06T09:43:51Z","dateModified":"2023-04-06T09:43:51Z","author":{"@type":"Person","name":"Qiao"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tanjoe.github.io/posts/%E4%BB%8Ehexo%E5%88%B0hugo/"},"publisher":{"@type":"Organization","name":"Qiao","logo":{"@type":"ImageObject","url":"https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tanjoe.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://tanjoe.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tanjoe.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://tanjoe.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tanjoe.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tanjoe.github.io/posts/>Posts</a></div><h1 class=post-title>从Hexo到Hugo</h1><div class=post-meta><span title='2023-04-06 09:43:51 +0000 UTC'>2023-04-06</span>&nbsp;·&nbsp;Qiao</div></header><div class=post-content><h1 id=从hexo到hugo>从Hexo到Hugo<a hidden class=anchor aria-hidden=true href=#从hexo到hugo>#</a></h1><h2 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h2><p>促使我从WordPress搬迁到Hexo，再决定从Hexo搬迁到Hugo的动机是：想尽可能简化写博客的流程，减少除文章撰写以外一切无关事务的精力消耗。</p><p>这一追求源于我对自身的观察。一天的精力里往往绝大部分都投入在工作之上，在闲暇中再挤出时间投入写作对意志力是个考验。以往使用WordPress时，一旦VPS的访问速度不佳，那登录后台、打开编辑器、调整样式过程中等待耗费的时间，就足以将不多的意志力消磨干净。</p><p>后续切到Hexo+Github Pages后，不得不说，这让博客的发布顺畅不少，不再需要登录后台，几乎不需要考虑排版，迁移站点时也不再有数据库的顾虑。唯一的麻烦是，每次修改文件后，需要调用Hexo CLI重新生成站点并推送到Github Pages仓库。这也意味着本地总得准备一份Node.js环境。思考一番后，前面通过<a href=%E4%BD%BF%E7%94%A8Github%20Actions%E9%83%A8%E7%BD%B2Hexo.md>使用Github Actions部署Hexo</a>把生成和部署也自动化了，只需要写文章并推送即可。</p><p>这么愉快地用了些时日，但在和Obsidian的配合使用中，又发现了新的矛盾：</p><ul><li><a href=https://hexo.io/docs/asset-folders.html>Hexo如果需要用相对路径引用图片，图片应置于文章同名的文件夹下</a>。而在Obsidian中，我所采取的方式是图片集中放置于media目录下</li><li>笔记现在总是用Obsidian创建，但需要为Hexo复制一份需要发布的文章及资源，而重复总是不利于维护的</li><li>如果将Hexo仓库置于Obsidian Vault中，再将需要发布的文章直接放到Hexo仓库的posts目录下，虽然不用复制文章，但Obsidian Vault中会带入Hexo/Node.js相关的文件。这些文件和笔记无关，在整理笔记时无异于噪音</li></ul><p>这些问题都可以通过修改笔记来迁就Hexo，但这就是前文所说的，文章撰写以外的事务。我现在相信：<strong>应当让博客工具迁就写作习惯，而不是调整写作习惯来适应工具</strong>。</p><h2 id=方法>方法<a hidden class=anchor aria-hidden=true href=#方法>#</a></h2><p>为解决以上矛盾，想到的方法是：</p><ol><li>在Vault中新建一个文件夹（这里记作Publish），在其中初始化Git仓库，存放供发布的文章</li><li>新建一个静态站点文件夹，同样初始话Git仓库，Publish仓库作为Git子模块加入其中</li><li>静态站点生成器应支持相对路径，且对文件夹的名称无要求</li></ol><p>这样Obsidian Vault中只需要存放笔记，至于静态站点生成相关的内容则不再其中。为了方便博客发布的流程，还应该做到：</p><ol><li>推送静态站点仓库时，应自动生成和部署站点，免去本地生成站点的麻烦</li><li>在Publish仓库中推送时，应自动更新静态站点仓库，让子模块引用Publish仓库的最新提交，免去需要在两个仓库中提交和推送的麻烦</li></ol><p>做到这些后，应当可以：</p><ul><li>不需要为了发布而改变记录笔记的方式</li><li>只维护一份需发布的资源</li><li>只需推送文章到远端，站点即能自动更新，本地不需要配置环境或手动生成站点</li></ul><p>本想看看有没有办法让Hexo支持任意文件夹名的相对路径，但惊讶地发现并没有轻松的方式实现（我原以为这是非常常见的需求）。Gatsby/Jekyll/Hugo等一众工具也不原生支持此需求，这似乎与文件名到URL的映射有关。不过 <a href=https://github.com/zoni/obsidian-export>GitHub - zoni/obsidian-export: Rust library and CLI to export an Obsidian vault to regular Markdown</a> 提供了一个解决方式，遂决定切换到Hugo。</p><h2 id=实施>实施<a hidden class=anchor aria-hidden=true href=#实施>#</a></h2><h3 id=支持相对路径>支持相对路径<a hidden class=anchor aria-hidden=true href=#支持相对路径>#</a></h3><ol><li>在Obsidian Vault中新建一个文件夹（这里记为Publish），在其中初始化Git仓库，存放供发布的文章。在Github上创建远端仓库并推送</li><li>用<code>hugo new site</code>命令创建站点文件夹（这里记为Site），同样初始化Git仓库。在Github上创建<code>xxx.github.io</code>名称的仓库并推送</li><li>与Hexo一样，Hugo同样支持主题，这里选用了<a href=https://themes.gohugo.io/themes/hugo-papermod/>PaperMod | Hugo Themes</a></li><li>在主题的<code>layouts/_default/_markup/render-image.html</code>中，加入以下代码片段以支持相对路径引用图片：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl>{{- $url := urls.Parse .Destination -}}
</span></span><span class=line><span class=cl>{{- $scheme := $url.Scheme -}}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>a</span> <span class=na>href</span><span class=o>=</span><span class=s>&#34;
</span></span></span><span class=line><span class=cl><span class=s>  {{- if eq $scheme &#34;</span><span class=err>&#34;</span> <span class=na>-</span><span class=err>}}</span>
</span></span><span class=line><span class=cl>    <span class=err>{{</span><span class=na>-</span> <span class=na>if</span> <span class=na>strings</span><span class=err>.</span><span class=na>HasSuffix</span> <span class=err>$</span><span class=na>url</span><span class=err>.</span><span class=na>Path</span> <span class=err>&#34;.</span><span class=na>md</span><span class=err>&#34;</span> <span class=na>-</span><span class=err>}}</span>
</span></span><span class=line><span class=cl>      <span class=err>{{</span><span class=na>-</span> <span class=na>relref</span> <span class=err>.</span><span class=na>Page</span> <span class=err>.</span><span class=na>Destination</span> <span class=err>|</span> <span class=na>safeURL</span> <span class=na>-</span><span class=err>}}</span>
</span></span><span class=line><span class=cl>    <span class=err>{{</span><span class=na>-</span> <span class=na>else</span> <span class=na>-</span><span class=err>}}</span>
</span></span><span class=line><span class=cl>      <span class=err>{{</span><span class=na>-</span> <span class=err>.</span><span class=na>Destination</span> <span class=err>|</span> <span class=na>safeURL</span> <span class=na>-</span><span class=err>}}</span>
</span></span><span class=line><span class=cl>    <span class=err>{{</span><span class=na>-</span> <span class=na>end</span> <span class=na>-</span><span class=err>}}</span>
</span></span><span class=line><span class=cl>  <span class=err>{{</span><span class=na>-</span> <span class=na>else</span> <span class=na>-</span><span class=err>}}</span>
</span></span><span class=line><span class=cl>    <span class=err>{{</span><span class=na>-</span> <span class=err>.</span><span class=na>Destination</span> <span class=err>|</span> <span class=na>safeURL</span> <span class=na>-</span><span class=err>}}</span>
</span></span><span class=line><span class=cl>  <span class=err>{{</span><span class=na>-</span> <span class=na>end</span> <span class=na>-</span><span class=err>}}&#34;</span>
</span></span><span class=line><span class=cl>  <span class=err>{{</span><span class=na>-</span> <span class=na>with</span> <span class=err>.</span><span class=na>Title</span> <span class=err>}}</span> <span class=na>title</span><span class=o>=</span><span class=s>&#34;{{ . | safeHTML }}&#34;</span><span class=err>{{</span><span class=na>-</span> <span class=na>end</span> <span class=na>-</span><span class=err>}}</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  {{- .Text | safeHTML -}}
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>a</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{{- /* whitespace stripped here to avoid trailing newline in rendered result caused by file EOL */ -}}
</span></span></code></pre></div><ol start=5><li>运行<code>hugo server -D</code>，在本地搭建站点服务器，发现站点图片显示正常</li></ol><h3 id=cicd配置>CI/CD配置<a hidden class=anchor aria-hidden=true href=#cicd配置>#</a></h3><p>现在考虑站点生成和部署的CI流程。</p><h4 id=deploy-key与token>Deploy key与Token<a hidden class=anchor aria-hidden=true href=#deploy-key与token>#</a></h4><p>为了让CI机器能访问Github上的仓库，需要创建Personal access tokens或仓库的Depoly keys。Github的Personal access tokesn现在又分Fine-grained tokens和Classic tokens，前者可以指定token到仓库细粒度的权限；至于Deploy keys，原本就是控制单个仓库的读写权限的，在<a href=%E4%BD%BF%E7%94%A8Github%20Actions%E9%83%A8%E7%BD%B2Hexo.md>使用Github Actions部署Hexo</a>有所提及。</p><p>Site仓库需要访问Publish仓库。由于之前创建过一对SSH秘钥作为Deploy keys，这里不妨复用。在Publish仓库界面，点击Settings -> Deploy keys -> Add deploy key，填入任意title，value则是公钥的内容。Site不需要也不应该写入Publish，故不勾选Allow Write Access。</p><p><img src=/posts/media/Pasted%20image%2020230407173337.png></p><p>为了方便，希望在Publish仓库中有推送时，Site仓库能自动关联Publish的最新提交。这需要Publish仓库能访问Site，通知有新的提交到来。</p><p>点击头像 -> Settings -> Developer Settings -> Personal access tokens -> Fine-grained tokens -> Generate new token，创建一个访问Site的Token，注意Contents权限为Read and write.</p><p><img src=/posts/media/Pasted%20image%2020230407190432.png></p><p>复制Token的值，在Publish仓库界面，点击Settings -> Secrets and variables -> Actions -> New repository secret，Name设置为PAT（下文的Github Actions配置会用Name索引到此secret），Value则填入Token的值。</p><p>在Site仓库中，点击Settings -> Secrets -> Actions -> New repository secret，Name设置为<code>BLOG_REPO_DEPLOY_PRIVATE_KEY</code>，Value则填入私钥的内容。</p><p><img src=/posts/media/Pasted%20image%2020230407173703.png></p><h4 id=创建配置>创建配置<a hidden class=anchor aria-hidden=true href=#创建配置>#</a></h4><p>在Publish仓库中，新建<code>.github/workflows/trigger_hugo.yml</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>trigger github pages build</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>push</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>branches</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>master</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>build</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Dispatch event</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>peter-evans/repository-dispatch@v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>token</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.PAT }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>repository</span><span class=p>:</span><span class=w> </span><span class=l>tanjoe/tanjoe.github.io</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>event-type</span><span class=p>:</span><span class=w> </span><span class=l>posts-push</span><span class=w>
</span></span></span></code></pre></div><p>每当向Publish仓库master分支推送时，<a href=https://github.com/peter-evans/repository-dispatch>repository-dispatch</a> 就会向Site仓库发送<code>posts-push</code>类型的事件。</p><p>在Site仓库中，新建<code>.github/workflows/update_posts.yml</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Update posts in submodule</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>repository_dispatch</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>types</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=l>posts-push]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c># Allows you to run this workflow manually from the Actions tab or through HTTP API</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>workflow_dispatch</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>sync</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Sync submodule</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Checkout</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ssh-key</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.BLOG_REPO_DEPLOY_PRIVATE_KEY }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>submodules</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>lfs</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># Update references</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Git Sumbodule Update</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>        git pull --recurse-submodules
</span></span></span><span class=line><span class=cl><span class=sd>        git submodule update --remote --recursive</span><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Commit update</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>        git config --global user.name &#39;Git bot&#39;
</span></span></span><span class=line><span class=cl><span class=sd>        git config --global user.email &#39;bot@noreply.github.com&#39;
</span></span></span><span class=line><span class=cl><span class=sd>        git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}
</span></span></span><span class=line><span class=cl><span class=sd>        git commit -am &#34;Auto updated submodule references&#34; &amp;&amp; git push || echo &#34;No changes to commit&#34;</span><span class=w>        
</span></span></span></code></pre></div><p>每当收到<code>posts-push</code>的事件，或Action被手动触发时，此Action会拉取子模组，在主仓库自动创建新提交并推送。</p><p>在Site仓库中，再创建<code>.github/workflows/hugo_deploy.yml</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>pages-auto-build-deploy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>push</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>branches</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>master</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>workflow_run</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>workflows</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=s2>&#34;Update posts in submodule&#34;</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>types</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>completed</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>build-and-deploy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Sync repo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>submodules</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>ssh-key</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.BLOG_REPO_DEPLOY_PRIVATE_KEY }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>lfs</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Setup Hugo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>peaceiris/actions-hugo@v2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>hugo-version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;latest&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>extended</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Build Hugo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>hugo --minify</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Deploy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>peaceiris/actions-gh-pages@v3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>github_token</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.GITHUB_TOKEN }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>publish_dir</span><span class=p>:</span><span class=w> </span><span class=l>./public</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>commit_message</span><span class=p>:</span><span class=w> </span><span class=l>${{ github.event.head_commit.message }}</span><span class=w>
</span></span></span></code></pre></div><p>这样每当master分支有新的推送，或名为<code>Update posts in submodule</code>的workflow执行完成时（也就是<code>update_posts.yml</code>对应的workflow），执行build-and-deploy。先通过ssh-key拉取子模块，也就是Publish仓库（以及模板项目仓库），使用 <a href=https://github.com/marketplace/actions/hugo-setup>Hugo setup</a> 生成站点，使用 <a href=https://github.com/marketplace/actions/github-pages-action>GitHub Pages action</a> 将目录下的<code>./public</code>推送到仓库的gh-pages分支。</p><p><code>update_posts.yml</code>的Action执行时本身就会往master分支推送，为什么还要单独指定<code>workflow_run</code>的部分呢？</p><p>原因在<a href=https://docs.github.com/en/actions/using-workflows/triggering-a-workflow#triggering-a-workflow-from-a-workflow>Triggering a workflow - GitHub Docs</a>有所解释：</p><blockquote><p>When you use the repository&rsquo;s <code>GITHUB_TOKEN</code> to perform tasks, events triggered by the <code>GITHUB_TOKEN</code>, with the exception of <code>workflow_dispatch</code> and <code>repository_dispatch</code>, will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository&rsquo;s <code>GITHUB_TOKEN</code>, a new workflow will not run even when the repository contains a workflow configured to run when <code>push</code> events occur.</p></blockquote><p>即用GITHUB_TOKEN触发的任务默认不会执行，以免无意间创建递归的任务。故这里要用<code>workflow_run</code>显示指定此Action可以被另一个Action触发。</p><p>最后，Github Pages的默认部署分支是master，而master分支现在存放的是Hugo项目的文件，静态站点的内容在gh-pages分支。故要在Site仓库页面的Settings -> Pages -> Build and deployment中，指定gh-pages分支作为部署分支。</p><p><img src=/posts/media/Pasted%20image%2020230407192530.png></p><p>大功告成！现在在Publish仓库中添加文章并推送，站点就会自动生成并部署了。</p><h1 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h1><ul><li><a href=%E4%BD%BF%E7%94%A8Github%20Actions%E9%83%A8%E7%BD%B2Hexo.md>使用Github Actions部署Hexo</a></li><li><a href=https://lucumt.info/post/hugo/using-github-action-to-auto-build-deploy/>利用GitHub Action实现Hugo博客在GitHub Pages自动部署 - 飞狐的部落格</a></li><li><a href=https://github.com/peter-evans/repository-dispatch>GitHub - peter-evans/repository-dispatch: A GitHub action to create a repository dispatch event</a></li><li><a href=https://github.com/orgs/community/discussions/26323>Triggering by other repository · community · Discussion #26323 · GitHub</a></li><li><a href=https://stackoverflow.com/questions/64407333/using-github-actions-to-automatically-update-the-repos-submodules>git - Using GitHub Actions to automatically update the repo&rsquo;s submodules - Stack Overflow</a></li><li><a href=https://stackoverflow.com/questions/60418323/triggering-a-new-workflow-from-another-workflow>github actions - Triggering a new workflow from another workflow? - Stack Overflow</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://tanjoe.github.io/tags/hexo/>Hexo</a></li><li><a href=https://tanjoe.github.io/tags/hugo/>Hugo</a></li><li><a href=https://tanjoe.github.io/tags/blog/>Blog</a></li><li><a href=https://tanjoe.github.io/tags/ci/cd/>CI/CD</a></li><li><a href=https://tanjoe.github.io/tags/%E6%8A%98%E8%85%BE/>折腾</a></li></ul><nav class=paginav><a class=next href=https://tanjoe.github.io/posts/debug-unity-project-on-android-device/><span class=title>Next »</span><br><span>Debug Unity Project on Android Device</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://tanjoe.github.io/>Qiao</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>