<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>处理托管C++的EEFileLoadException | Qiao</title><meta name=keywords content="C++,C"><meta name=description content="背景 因为业务的原因，需要从C++端调用一个C#库，设计的调用流程如下：
graph LR; n[&#34;Native C++&#34;]-->m[&#34;Managed C++&#34;]; m-->s[&#34;C#&#34;]; 工程的组织如下：
graph LR; subgraph &#34;Native C++&#34; user[&#34;Native C++库使用者&#34;] nt[&#34;Native C++库单元测试&#34;]; n[&#34;Native C++库&#34;]; end m[&#34;Managed C++库&#34;]; subgraph &#34;C#&#34; s[&#34;C#库&#34;]; st[&#34;C#库单元测试&#34;]; end user-.->|显式加载|n; nt-->n; n-->m; m-->s; st-->s; 动态库工程：
Native C++库：生成Unmanaged.lib和Unmanaged.dll Managed C++库：生成Wrapper.lib和Wrapper.dll C#库：生成Managed.dll 可执行文件工程：
Native C++库单元测试：生成UnmanagedTest.exe C#库单元测试：生成ManagedTest.exe Native C++库使用者：生成LibConsumer.exe。与单元测试工程不同的是，LibConsumer.exe会在运行期间调用::LoadLibrary()显示加载Unmanaged.dll，在链接期也不会链接到Unmanaged.lib和Wrapper.lib 现在情况如下：C#库编写完成，且C#库单元测试通过，但Native C++库单元测试未通过，LibConsumer.exe加载Unmanaged.dll也会失败（::LoadLibrary()返回句柄为NULL）。调试发现在托管C++层创建C#对象时会出现EEFileLoadException导致程序崩溃。
EEFileLoadException Microsoft Docs没有找到对EEFileLoadException的描述，不过Stackoverflow上有个简要的回答，见EEFileLoadException When Loading C++ DLL in Managed DLL：
An EEFileLoadException indicates the executable cannot find or load one of it&rsquo;s dependencies. That can of course has different causes (path problem, mixing configurations, mixing platforms)."><meta name=author content="Qiao"><link rel=canonical href=https://tanjoe.github.io/posts/%E5%A4%84%E7%90%86%E6%89%98%E7%AE%A1c++%E7%9A%84eefileloadexception/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"forest",themeVariables:{lineColor:"#fafafa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><meta property="og:title" content="处理托管C++的EEFileLoadException"><meta property="og:description" content="背景 因为业务的原因，需要从C++端调用一个C#库，设计的调用流程如下：
graph LR; n[&#34;Native C++&#34;]-->m[&#34;Managed C++&#34;]; m-->s[&#34;C#&#34;]; 工程的组织如下：
graph LR; subgraph &#34;Native C++&#34; user[&#34;Native C++库使用者&#34;] nt[&#34;Native C++库单元测试&#34;]; n[&#34;Native C++库&#34;]; end m[&#34;Managed C++库&#34;]; subgraph &#34;C#&#34; s[&#34;C#库&#34;]; st[&#34;C#库单元测试&#34;]; end user-.->|显式加载|n; nt-->n; n-->m; m-->s; st-->s; 动态库工程：
Native C++库：生成Unmanaged.lib和Unmanaged.dll Managed C++库：生成Wrapper.lib和Wrapper.dll C#库：生成Managed.dll 可执行文件工程：
Native C++库单元测试：生成UnmanagedTest.exe C#库单元测试：生成ManagedTest.exe Native C++库使用者：生成LibConsumer.exe。与单元测试工程不同的是，LibConsumer.exe会在运行期间调用::LoadLibrary()显示加载Unmanaged.dll，在链接期也不会链接到Unmanaged.lib和Wrapper.lib 现在情况如下：C#库编写完成，且C#库单元测试通过，但Native C++库单元测试未通过，LibConsumer.exe加载Unmanaged.dll也会失败（::LoadLibrary()返回句柄为NULL）。调试发现在托管C++层创建C#对象时会出现EEFileLoadException导致程序崩溃。
EEFileLoadException Microsoft Docs没有找到对EEFileLoadException的描述，不过Stackoverflow上有个简要的回答，见EEFileLoadException When Loading C++ DLL in Managed DLL：
An EEFileLoadException indicates the executable cannot find or load one of it&rsquo;s dependencies. That can of course has different causes (path problem, mixing configurations, mixing platforms)."><meta property="og:type" content="article"><meta property="og:url" content="https://tanjoe.github.io/posts/%E5%A4%84%E7%90%86%E6%89%98%E7%AE%A1c++%E7%9A%84eefileloadexception/"><meta property="og:image" content="https://tanjoe.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-04T11:58:00+00:00"><meta property="article:modified_time" content="2020-11-04T11:58:00+00:00"><meta property="og:site_name" content="Qiao"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tanjoe.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="处理托管C++的EEFileLoadException"><meta name=twitter:description content="背景 因为业务的原因，需要从C++端调用一个C#库，设计的调用流程如下：
graph LR; n[&#34;Native C++&#34;]-->m[&#34;Managed C++&#34;]; m-->s[&#34;C#&#34;]; 工程的组织如下：
graph LR; subgraph &#34;Native C++&#34; user[&#34;Native C++库使用者&#34;] nt[&#34;Native C++库单元测试&#34;]; n[&#34;Native C++库&#34;]; end m[&#34;Managed C++库&#34;]; subgraph &#34;C#&#34; s[&#34;C#库&#34;]; st[&#34;C#库单元测试&#34;]; end user-.->|显式加载|n; nt-->n; n-->m; m-->s; st-->s; 动态库工程：
Native C++库：生成Unmanaged.lib和Unmanaged.dll Managed C++库：生成Wrapper.lib和Wrapper.dll C#库：生成Managed.dll 可执行文件工程：
Native C++库单元测试：生成UnmanagedTest.exe C#库单元测试：生成ManagedTest.exe Native C++库使用者：生成LibConsumer.exe。与单元测试工程不同的是，LibConsumer.exe会在运行期间调用::LoadLibrary()显示加载Unmanaged.dll，在链接期也不会链接到Unmanaged.lib和Wrapper.lib 现在情况如下：C#库编写完成，且C#库单元测试通过，但Native C++库单元测试未通过，LibConsumer.exe加载Unmanaged.dll也会失败（::LoadLibrary()返回句柄为NULL）。调试发现在托管C++层创建C#对象时会出现EEFileLoadException导致程序崩溃。
EEFileLoadException Microsoft Docs没有找到对EEFileLoadException的描述，不过Stackoverflow上有个简要的回答，见EEFileLoadException When Loading C++ DLL in Managed DLL：
An EEFileLoadException indicates the executable cannot find or load one of it&rsquo;s dependencies. That can of course has different causes (path problem, mixing configurations, mixing platforms)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tanjoe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"处理托管C++的EEFileLoadException","item":"https://tanjoe.github.io/posts/%E5%A4%84%E7%90%86%E6%89%98%E7%AE%A1c++%E7%9A%84eefileloadexception/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"处理托管C++的EEFileLoadException","name":"处理托管C\u002b\u002b的EEFileLoadException","description":"背景 因为业务的原因，需要从C++端调用一个C#库，设计的调用流程如下：\ngraph LR; n[\u0026#34;Native C++\u0026#34;]--\u0026gt;m[\u0026#34;Managed C++\u0026#34;]; m--\u0026gt;s[\u0026#34;C#\u0026#34;]; 工程的组织如下：\ngraph LR; subgraph \u0026#34;Native C++\u0026#34; user[\u0026#34;Native C++库使用者\u0026#34;] nt[\u0026#34;Native C++库单元测试\u0026#34;]; n[\u0026#34;Native C++库\u0026#34;]; end m[\u0026#34;Managed C++库\u0026#34;]; subgraph \u0026#34;C#\u0026#34; s[\u0026#34;C#库\u0026#34;]; st[\u0026#34;C#库单元测试\u0026#34;]; end user-.-\u0026gt;|显式加载|n; nt--\u0026gt;n; n--\u0026gt;m; m--\u0026gt;s; st--\u0026gt;s; 动态库工程：\nNative C++库：生成Unmanaged.lib和Unmanaged.dll Managed C++库：生成Wrapper.lib和Wrapper.dll C#库：生成Managed.dll 可执行文件工程：\nNative C++库单元测试：生成UnmanagedTest.exe C#库单元测试：生成ManagedTest.exe Native C++库使用者：生成LibConsumer.exe。与单元测试工程不同的是，LibConsumer.exe会在运行期间调用::LoadLibrary()显示加载Unmanaged.dll，在链接期也不会链接到Unmanaged.lib和Wrapper.lib 现在情况如下：C#库编写完成，且C#库单元测试通过，但Native C++库单元测试未通过，LibConsumer.exe加载Unmanaged.dll也会失败（::LoadLibrary()返回句柄为NULL）。调试发现在托管C++层创建C#对象时会出现EEFileLoadException导致程序崩溃。\nEEFileLoadException Microsoft Docs没有找到对EEFileLoadException的描述，不过Stackoverflow上有个简要的回答，见EEFileLoadException When Loading C++ DLL in Managed DLL：\nAn EEFileLoadException indicates the executable cannot find or load one of it\u0026rsquo;s dependencies. That can of course has different causes (path problem, mixing configurations, mixing platforms).","keywords":["C++","C"],"articleBody":"背景 因为业务的原因，需要从C++端调用一个C#库，设计的调用流程如下：\ngraph LR; n[\"Native C++\"]--\u003em[\"Managed C++\"]; m--\u003es[\"C#\"]; 工程的组织如下：\ngraph LR; subgraph \"Native C++\" user[\"Native C++库使用者\"] nt[\"Native C++库单元测试\"]; n[\"Native C++库\"]; end m[\"Managed C++库\"]; subgraph \"C#\" s[\"C#库\"]; st[\"C#库单元测试\"]; end user-.-\u003e|显式加载|n; nt--\u003en; n--\u003em; m--\u003es; st--\u003es; 动态库工程：\nNative C++库：生成Unmanaged.lib和Unmanaged.dll Managed C++库：生成Wrapper.lib和Wrapper.dll C#库：生成Managed.dll 可执行文件工程：\nNative C++库单元测试：生成UnmanagedTest.exe C#库单元测试：生成ManagedTest.exe Native C++库使用者：生成LibConsumer.exe。与单元测试工程不同的是，LibConsumer.exe会在运行期间调用::LoadLibrary()显示加载Unmanaged.dll，在链接期也不会链接到Unmanaged.lib和Wrapper.lib 现在情况如下：C#库编写完成，且C#库单元测试通过，但Native C++库单元测试未通过，LibConsumer.exe加载Unmanaged.dll也会失败（::LoadLibrary()返回句柄为NULL）。调试发现在托管C++层创建C#对象时会出现EEFileLoadException导致程序崩溃。\nEEFileLoadException Microsoft Docs没有找到对EEFileLoadException的描述，不过Stackoverflow上有个简要的回答，见EEFileLoadException When Loading C++ DLL in Managed DLL：\nAn EEFileLoadException indicates the executable cannot find or load one of it’s dependencies. That can of course has different causes (path problem, mixing configurations, mixing platforms).\n即当可执行程序无法找到或加载它所依赖的动态库（更准确的说，是无法找到或加载C# asseembly文件，因为如果是VC的动态库，系统通常会报dll无法找到），程序会报EEFileLoadException。\n为什么无法找到Assembly？ 对于ManagedTest.exe，只需将Unmanaged.dll、Wrapper.dll、Managed.dll及Managed.dll自身依赖的Assembly复制到ManagedTest.exe同一目录下即可，这一点很好理解。\n对于LibConsumer.exe，文件目录如下：\n./LibConsumer.exe ./plugin/Unmanaged.dll ./plugin/Wrapper.dll ./plugin/Managed.dll #./plugin/OtherAssembly.dll #... Unmanaged.dll及其依赖项均置于plugin目录下，LibConsumer.exe在运行时会使用::LoadLibrary()加载./plugin/Unmanaged.dll，为什么会出现加载失败？\n这和Windows动态库的查找顺序有关。见Standard Search Order for Desktop Applications：\nIf SafeDllSearchMode is enabled, the search order is as follows:\nThe directory from which the application loaded. The system directory. Use the GetSystemDirectory function to get the path of this directory. The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. The Windows directory. Use the GetWindowsDirectory function to get the path of this directory. The current directory. The directories that are listed in the PATH environment variable. Note that this does not include the per-application path specified by the App Paths registry key. The App Paths key is not used when computing the DLL search path. If SafeDllSearchMode is disabled, the search order is as follows:\nThe directory from which the application loaded. The current directory. The system directory. Use the GetSystemDirectory function to get the path of this directory. The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. The Windows directory. Use the GetWindowsDirectory function to get the path of this directory. The directories that are listed in the PATH environment variable. Note that this does not include the per-application path specified by the App Paths registry key. The App Paths key is not used when computing the DLL search path. SafeDllSearchMode默认是开启的，因此Windows会按以下顺序查找DLL：\n应用程序的加载路径（也就是LibConsumer.exe的加载路径） system目录 16位system目录 Windows目录 用户当前目录 PATH环境变量里的目录 换而言之，LibConsumer.exe使用::LoadLibrary()加载Unmanaged.dll时，Windows并不会在Unmanaged.dll所在路径下查找Wrapper.dll等依赖项，而是直接从LibConsumer.exe所在路径下开始查找。因此，Wrapper.dll、Managed.dll等文件需要置于LibConsumer.exe同一目录下（或者用其余手段让Windows能够查找到它们）。\n","wordCount":"321","inLanguage":"en","datePublished":"2020-11-04T11:58:00Z","dateModified":"2020-11-04T11:58:00Z","author":{"@type":"Person","name":"Qiao"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tanjoe.github.io/posts/%E5%A4%84%E7%90%86%E6%89%98%E7%AE%A1c++%E7%9A%84eefileloadexception/"},"publisher":{"@type":"Organization","name":"Qiao","logo":{"@type":"ImageObject","url":"https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tanjoe.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://tanjoe.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tanjoe.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://tanjoe.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tanjoe.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tanjoe.github.io/posts/>Posts</a></div><h1 class=post-title>处理托管C++的EEFileLoadException</h1><div class=post-meta><span title='2020-11-04 11:58:00 +0000 UTC'>2020-11-04</span>&nbsp;·&nbsp;Qiao</div></header><div class=post-content><h2 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h2><p>因为业务的原因，需要从C++端调用一个C#库，设计的调用流程如下：</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph LR;
n[&#34;Native C++&#34;]--&gt;m[&#34;Managed C++&#34;];
m--&gt;s[&#34;C#&#34;];
</code></pre><p>工程的组织如下：</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph LR;
	subgraph &#34;Native C++&#34;
		user[&#34;Native C++库使用者&#34;]
		nt[&#34;Native C++库单元测试&#34;];
		n[&#34;Native C++库&#34;];
	end
	m[&#34;Managed C++库&#34;];
	subgraph &#34;C#&#34;
		s[&#34;C#库&#34;];
		st[&#34;C#库单元测试&#34;];
	end
	user-.-&gt;|显式加载|n;
	nt--&gt;n;
	n--&gt;m;
	m--&gt;s;
	st--&gt;s;
</code></pre><p>动态库工程：</p><ul><li>Native C++库：生成<code>Unmanaged.lib</code>和<code>Unmanaged.dll</code></li><li>Managed C++库：生成<code>Wrapper.lib</code>和<code>Wrapper.dll</code></li><li>C#库：生成<code>Managed.dll</code></li></ul><p>可执行文件工程：</p><ul><li>Native C++库单元测试：生成<code>UnmanagedTest.exe</code></li><li>C#库单元测试：生成<code>ManagedTest.exe</code></li><li>Native C++库使用者：生成<code>LibConsumer.exe</code>。与单元测试工程不同的是，<code>LibConsumer.exe</code>会在运行期间调用<code>::LoadLibrary()</code>显示加载<code>Unmanaged.dll</code>，在链接期也不会链接到<code>Unmanaged.lib</code>和<code>Wrapper.lib</code></li></ul><p>现在情况如下：C#库编写完成，且C#库单元测试通过，但Native C++库单元测试未通过，<code>LibConsumer.exe</code>加载<code>Unmanaged.dll</code>也会失败（<code>::LoadLibrary()</code>返回句柄为<code>NULL</code>）。调试发现在托管C++层创建C#对象时会出现EEFileLoadException导致程序崩溃。</p><h2 id=eefileloadexception>EEFileLoadException<a hidden class=anchor aria-hidden=true href=#eefileloadexception>#</a></h2><p><a href=https://docs.microsoft.com/en-us/>Microsoft Docs</a>没有找到对EEFileLoadException的描述，不过Stackoverflow上有个简要的回答，见<a href=https://stackoverflow.com/questions/16796335/eefileloadexception-when-loading-c-dll-in-managed-dll/35319991>EEFileLoadException When Loading C++ DLL in Managed DLL</a>：</p><blockquote><p>An EEFileLoadException indicates the executable cannot find or load one of it&rsquo;s dependencies. That can of course has different causes (path problem, mixing configurations, mixing platforms).</p></blockquote><p>即当可执行程序无法找到或加载它所依赖的动态库（更准确的说，是无法找到或加载<strong>C# asseembly文件</strong>，因为如果是VC的动态库，系统通常会报dll无法找到），程序会报EEFileLoadException。</p><h2 id=为什么无法找到assembly>为什么无法找到Assembly？<a hidden class=anchor aria-hidden=true href=#为什么无法找到assembly>#</a></h2><p>对于<code>ManagedTest.exe</code>，只需将<code>Unmanaged.dll</code>、<code>Wrapper.dll</code>、<code>Managed.dll</code>及<code>Managed.dll</code>自身依赖的Assembly复制到<code>ManagedTest.exe</code>同一目录下即可，这一点很好理解。</p><p>对于<code>LibConsumer.exe</code>，文件目录如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>./LibConsumer.exe
</span></span><span class=line><span class=cl>./plugin/Unmanaged.dll
</span></span><span class=line><span class=cl>./plugin/Wrapper.dll
</span></span><span class=line><span class=cl>./plugin/Managed.dll
</span></span><span class=line><span class=cl><span class=c1>#./plugin/OtherAssembly.dll</span>
</span></span><span class=line><span class=cl><span class=c1>#...</span>
</span></span></code></pre></div><p><code>Unmanaged.dll</code>及其依赖项均置于<code>plugin</code>目录下，<code>LibConsumer.exe</code>在运行时会使用<code>::LoadLibrary()</code>加载<code>./plugin/Unmanaged.dll</code>，为什么会出现加载失败？</p><p>这和Windows动态库的查找顺序有关。见<a href=https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order#standard-search-order-for-desktop-applications>Standard Search Order for Desktop Applications</a>：</p><blockquote><p>If <strong>SafeDllSearchMode</strong> is enabled, the search order is as follows:</p><ol><li>The directory from which the application loaded.</li><li>The system directory. Use the <a href=https://docs.microsoft.com/en-us/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsystemdirectorya><strong>GetSystemDirectory</strong></a> function to get the path of this directory.</li><li>The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched.</li><li>The Windows directory. Use the <a href=https://docs.microsoft.com/en-us/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getwindowsdirectorya><strong>GetWindowsDirectory</strong></a> function to get the path of this directory.</li><li>The current directory.</li><li>The directories that are listed in the PATH environment variable. Note that this does not include the per-application path specified by the <strong>App Paths</strong> registry key. The <strong>App Paths</strong> key is not used when computing the DLL search path.</li></ol><p>If <strong>SafeDllSearchMode</strong> is disabled, the search order is as follows:</p><ol><li>The directory from which the application loaded.</li><li>The current directory.</li><li>The system directory. Use the <a href=https://docs.microsoft.com/en-us/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsystemdirectorya><strong>GetSystemDirectory</strong></a> function to get the path of this directory.</li><li>The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched.</li><li>The Windows directory. Use the <a href=https://docs.microsoft.com/en-us/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getwindowsdirectorya><strong>GetWindowsDirectory</strong></a> function to get the path of this directory.</li><li>The directories that are listed in the PATH environment variable. Note that this does not include the per-application path specified by the <strong>App Paths</strong> registry key. The <strong>App Paths</strong> key is not used when computing the DLL search path.</li></ol></blockquote><p><code>SafeDllSearchMode</code>默认是开启的，因此Windows会按以下顺序查找DLL：</p><ol><li>应用程序的加载路径（也就是<code>LibConsumer.exe</code>的加载路径）</li><li>system目录</li><li>16位system目录</li><li>Windows目录</li><li>用户当前目录</li><li>PATH环境变量里的目录</li></ol><p>换而言之，<code>LibConsumer.exe</code>使用<code>::LoadLibrary()</code>加载<code>Unmanaged.dll</code>时，Windows并不会在<code>Unmanaged.dll</code>所在路径下查找<code>Wrapper.dll</code>等依赖项，而是直接从<code>LibConsumer.exe</code>所在路径下开始查找。因此，<code>Wrapper.dll</code>、<code>Managed.dll</code>等文件需要置于<code>LibConsumer.exe</code>同一目录下（或者用其余手段让Windows能够查找到它们）。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tanjoe.github.io/tags/c++/>c++</a></li><li><a href=https://tanjoe.github.io/tags/c/>C</a></li></ul><nav class=paginav><a class=prev href=https://tanjoe.github.io/posts/poor-man-s-profiler/><span class=title>« Prev</span><br><span>poor-man-s-profiler</span></a>
<a class=next href=https://tanjoe.github.io/posts/%E5%9C%A8windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%96%E8%AF%91qt-5-15-1/><span class=title>Next »</span><br><span>在Windows环境下编译Qt-5-15-1</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://tanjoe.github.io/>Qiao</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>