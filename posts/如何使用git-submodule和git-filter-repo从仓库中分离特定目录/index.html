<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>如何使用git submodule和git filter-repo从仓库中分离特定目录 | Qiao</title><meta name=keywords content="git"><meta name=description content="碰到了一个这样的场景：同事为了单元测试，将众多测试资源文件提交到了git仓库内，这导致仓库体积陡然膨胀。但另一方面，编写好的测试用例又确实依赖这些测试资源文件。那么，有没有办法能达到以下目标：
分离工程文件和测试资源，以便能够单独管理二者 清洗提交记录，将测试资源在提交历史中“抹去”，以便减小仓库的体积 搜索一番，发现了git submodule和git filter-repo两个工具刚好可以满足这两个需求。
1 git submodule的使用 submodule是git自带的一个工具，详细的介绍参见Git-工具-子模块，这里不再赘述，只简单说明如何利用git submodule满足上述需求。
1.1 从仓库中移除测试资源 假设工程结构如下：
├─MyLib │ ├─include │ └─src ├─MyLibTest ├─assets └─src 其中MyLib为库的工程，而MyLibTest则是MyLib的单元测试工程，测试资源存放在MyLibTest/assets下，也正是我们需要移除的目录。
首先，在git bash中执行
git rm -r --cached MyLibTest/assets 将MyLibTest/assets从git仓库索引中移除，但不实际删除该目录。
关于git rm的使用，参见git-rm
1.2 新建测试资源仓库 新建远程仓库 在git服务器上新建一个仓库，记作MyLibTestResource，用于存放测试资源。
新建本地仓库 新建一个目录，这里记作TestResource，在其中建立git仓库，将MyLibTest/assets中的内容复制到该目录下，随后提交。再执行
git remote add origin git@MyLibTestResource.git #git@MyLibTestResource.git替换为MyLibTestResource的真实git地址 添加远程仓库，随后执行git push推送即可。
1.3 添加子模块 回到MyLib下，执行
git submodule add git@MyLibTestResource.git MyLibTest/assets 添加子模块MyLibTestResource，子模块的内容会同步到MyLibTest/assets下。
1.4 克隆包含子模块的项目 克隆包含子模块的项目有二种方法：一种是先克隆父项目，再更新子模块；另一种是直接递归克隆整个项目。
克隆父项目，再更新子模块 #克隆父项目MyLib git clone git@MyLib.git #git@MyLib.git替换为MyLib的真实git地址 #初始化子模块 cd MyLib git submodule init #更新子模块 git submodule update 递归克隆整个项目 git clone git@MyLib."><meta name=author content="Qiao"><link rel=canonical href=https://tanjoe.github.io/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git-submodule%E5%92%8Cgit-filter-repo%E4%BB%8E%E4%BB%93%E5%BA%93%E4%B8%AD%E5%88%86%E7%A6%BB%E7%89%B9%E5%AE%9A%E7%9B%AE%E5%BD%95/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"forest",themeVariables:{lineColor:"#fafafa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><meta property="og:title" content="如何使用git submodule和git filter-repo从仓库中分离特定目录"><meta property="og:description" content="碰到了一个这样的场景：同事为了单元测试，将众多测试资源文件提交到了git仓库内，这导致仓库体积陡然膨胀。但另一方面，编写好的测试用例又确实依赖这些测试资源文件。那么，有没有办法能达到以下目标：
分离工程文件和测试资源，以便能够单独管理二者 清洗提交记录，将测试资源在提交历史中“抹去”，以便减小仓库的体积 搜索一番，发现了git submodule和git filter-repo两个工具刚好可以满足这两个需求。
1 git submodule的使用 submodule是git自带的一个工具，详细的介绍参见Git-工具-子模块，这里不再赘述，只简单说明如何利用git submodule满足上述需求。
1.1 从仓库中移除测试资源 假设工程结构如下：
├─MyLib │ ├─include │ └─src ├─MyLibTest ├─assets └─src 其中MyLib为库的工程，而MyLibTest则是MyLib的单元测试工程，测试资源存放在MyLibTest/assets下，也正是我们需要移除的目录。
首先，在git bash中执行
git rm -r --cached MyLibTest/assets 将MyLibTest/assets从git仓库索引中移除，但不实际删除该目录。
关于git rm的使用，参见git-rm
1.2 新建测试资源仓库 新建远程仓库 在git服务器上新建一个仓库，记作MyLibTestResource，用于存放测试资源。
新建本地仓库 新建一个目录，这里记作TestResource，在其中建立git仓库，将MyLibTest/assets中的内容复制到该目录下，随后提交。再执行
git remote add origin git@MyLibTestResource.git #git@MyLibTestResource.git替换为MyLibTestResource的真实git地址 添加远程仓库，随后执行git push推送即可。
1.3 添加子模块 回到MyLib下，执行
git submodule add git@MyLibTestResource.git MyLibTest/assets 添加子模块MyLibTestResource，子模块的内容会同步到MyLibTest/assets下。
1.4 克隆包含子模块的项目 克隆包含子模块的项目有二种方法：一种是先克隆父项目，再更新子模块；另一种是直接递归克隆整个项目。
克隆父项目，再更新子模块 #克隆父项目MyLib git clone git@MyLib.git #git@MyLib.git替换为MyLib的真实git地址 #初始化子模块 cd MyLib git submodule init #更新子模块 git submodule update 递归克隆整个项目 git clone git@MyLib."><meta property="og:type" content="article"><meta property="og:url" content="https://tanjoe.github.io/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git-submodule%E5%92%8Cgit-filter-repo%E4%BB%8E%E4%BB%93%E5%BA%93%E4%B8%AD%E5%88%86%E7%A6%BB%E7%89%B9%E5%AE%9A%E7%9B%AE%E5%BD%95/"><meta property="og:image" content="https://tanjoe.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-23T10:09:23+00:00"><meta property="article:modified_time" content="2020-07-23T10:09:23+00:00"><meta property="og:site_name" content="Qiao"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tanjoe.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="如何使用git submodule和git filter-repo从仓库中分离特定目录"><meta name=twitter:description content="碰到了一个这样的场景：同事为了单元测试，将众多测试资源文件提交到了git仓库内，这导致仓库体积陡然膨胀。但另一方面，编写好的测试用例又确实依赖这些测试资源文件。那么，有没有办法能达到以下目标：
分离工程文件和测试资源，以便能够单独管理二者 清洗提交记录，将测试资源在提交历史中“抹去”，以便减小仓库的体积 搜索一番，发现了git submodule和git filter-repo两个工具刚好可以满足这两个需求。
1 git submodule的使用 submodule是git自带的一个工具，详细的介绍参见Git-工具-子模块，这里不再赘述，只简单说明如何利用git submodule满足上述需求。
1.1 从仓库中移除测试资源 假设工程结构如下：
├─MyLib │ ├─include │ └─src ├─MyLibTest ├─assets └─src 其中MyLib为库的工程，而MyLibTest则是MyLib的单元测试工程，测试资源存放在MyLibTest/assets下，也正是我们需要移除的目录。
首先，在git bash中执行
git rm -r --cached MyLibTest/assets 将MyLibTest/assets从git仓库索引中移除，但不实际删除该目录。
关于git rm的使用，参见git-rm
1.2 新建测试资源仓库 新建远程仓库 在git服务器上新建一个仓库，记作MyLibTestResource，用于存放测试资源。
新建本地仓库 新建一个目录，这里记作TestResource，在其中建立git仓库，将MyLibTest/assets中的内容复制到该目录下，随后提交。再执行
git remote add origin git@MyLibTestResource.git #git@MyLibTestResource.git替换为MyLibTestResource的真实git地址 添加远程仓库，随后执行git push推送即可。
1.3 添加子模块 回到MyLib下，执行
git submodule add git@MyLibTestResource.git MyLibTest/assets 添加子模块MyLibTestResource，子模块的内容会同步到MyLibTest/assets下。
1.4 克隆包含子模块的项目 克隆包含子模块的项目有二种方法：一种是先克隆父项目，再更新子模块；另一种是直接递归克隆整个项目。
克隆父项目，再更新子模块 #克隆父项目MyLib git clone git@MyLib.git #git@MyLib.git替换为MyLib的真实git地址 #初始化子模块 cd MyLib git submodule init #更新子模块 git submodule update 递归克隆整个项目 git clone git@MyLib."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tanjoe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"如何使用git submodule和git filter-repo从仓库中分离特定目录","item":"https://tanjoe.github.io/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git-submodule%E5%92%8Cgit-filter-repo%E4%BB%8E%E4%BB%93%E5%BA%93%E4%B8%AD%E5%88%86%E7%A6%BB%E7%89%B9%E5%AE%9A%E7%9B%AE%E5%BD%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何使用git submodule和git filter-repo从仓库中分离特定目录","name":"如何使用git submodule和git filter-repo从仓库中分离特定目录","description":"碰到了一个这样的场景：同事为了单元测试，将众多测试资源文件提交到了git仓库内，这导致仓库体积陡然膨胀。但另一方面，编写好的测试用例又确实依赖这些测试资源文件。那么，有没有办法能达到以下目标：\n分离工程文件和测试资源，以便能够单独管理二者 清洗提交记录，将测试资源在提交历史中“抹去”，以便减小仓库的体积 搜索一番，发现了git submodule和git filter-repo两个工具刚好可以满足这两个需求。\n1 git submodule的使用 submodule是git自带的一个工具，详细的介绍参见Git-工具-子模块，这里不再赘述，只简单说明如何利用git submodule满足上述需求。\n1.1 从仓库中移除测试资源 假设工程结构如下：\n├─MyLib │ ├─include │ └─src ├─MyLibTest ├─assets └─src 其中MyLib为库的工程，而MyLibTest则是MyLib的单元测试工程，测试资源存放在MyLibTest/assets下，也正是我们需要移除的目录。\n首先，在git bash中执行\ngit rm -r --cached MyLibTest/assets 将MyLibTest/assets从git仓库索引中移除，但不实际删除该目录。\n关于git rm的使用，参见git-rm\n1.2 新建测试资源仓库 新建远程仓库 在git服务器上新建一个仓库，记作MyLibTestResource，用于存放测试资源。\n新建本地仓库 新建一个目录，这里记作TestResource，在其中建立git仓库，将MyLibTest/assets中的内容复制到该目录下，随后提交。再执行\ngit remote add origin git@MyLibTestResource.git #git@MyLibTestResource.git替换为MyLibTestResource的真实git地址 添加远程仓库，随后执行git push推送即可。\n1.3 添加子模块 回到MyLib下，执行\ngit submodule add git@MyLibTestResource.git MyLibTest/assets 添加子模块MyLibTestResource，子模块的内容会同步到MyLibTest/assets下。\n1.4 克隆包含子模块的项目 克隆包含子模块的项目有二种方法：一种是先克隆父项目，再更新子模块；另一种是直接递归克隆整个项目。\n克隆父项目，再更新子模块 #克隆父项目MyLib git clone git@MyLib.git #git@MyLib.git替换为MyLib的真实git地址 #初始化子模块 cd MyLib git submodule init #更新子模块 git submodule update 递归克隆整个项目 git clone git@MyLib.","keywords":["git"],"articleBody":"碰到了一个这样的场景：同事为了单元测试，将众多测试资源文件提交到了git仓库内，这导致仓库体积陡然膨胀。但另一方面，编写好的测试用例又确实依赖这些测试资源文件。那么，有没有办法能达到以下目标：\n分离工程文件和测试资源，以便能够单独管理二者 清洗提交记录，将测试资源在提交历史中“抹去”，以便减小仓库的体积 搜索一番，发现了git submodule和git filter-repo两个工具刚好可以满足这两个需求。\n1 git submodule的使用 submodule是git自带的一个工具，详细的介绍参见Git-工具-子模块，这里不再赘述，只简单说明如何利用git submodule满足上述需求。\n1.1 从仓库中移除测试资源 假设工程结构如下：\n├─MyLib │ ├─include │ └─src ├─MyLibTest ├─assets └─src 其中MyLib为库的工程，而MyLibTest则是MyLib的单元测试工程，测试资源存放在MyLibTest/assets下，也正是我们需要移除的目录。\n首先，在git bash中执行\ngit rm -r --cached MyLibTest/assets 将MyLibTest/assets从git仓库索引中移除，但不实际删除该目录。\n关于git rm的使用，参见git-rm\n1.2 新建测试资源仓库 新建远程仓库 在git服务器上新建一个仓库，记作MyLibTestResource，用于存放测试资源。\n新建本地仓库 新建一个目录，这里记作TestResource，在其中建立git仓库，将MyLibTest/assets中的内容复制到该目录下，随后提交。再执行\ngit remote add origin git@MyLibTestResource.git #git@MyLibTestResource.git替换为MyLibTestResource的真实git地址 添加远程仓库，随后执行git push推送即可。\n1.3 添加子模块 回到MyLib下，执行\ngit submodule add git@MyLibTestResource.git MyLibTest/assets 添加子模块MyLibTestResource，子模块的内容会同步到MyLibTest/assets下。\n1.4 克隆包含子模块的项目 克隆包含子模块的项目有二种方法：一种是先克隆父项目，再更新子模块；另一种是直接递归克隆整个项目。\n克隆父项目，再更新子模块 #克隆父项目MyLib git clone git@MyLib.git #git@MyLib.git替换为MyLib的真实git地址 #初始化子模块 cd MyLib git submodule init #更新子模块 git submodule update 递归克隆整个项目 git clone git@MyLib.git --recursive 2 git filter-repo的使用 利用git submodule可以将测试资源从MyLib中分离，但MyLib仓库中仍然记录着测试资源的提交与更改，这导致仓库体积仍然很庞大。那么，如何改写git提交历史，将测试资源相关的提交与更改从历史中“抹去”呢？\n对于重写历史，我们已有git commit --amend、git rebase等工具可用，但这些指令都只适用于一个或几个提交的修改，修改大量提交时用这些指令会显得非常繁琐。Git还提供了一个git filter-branch用于改写历史中的大量提交，不过很可惜，它至少有以下缺陷：\n清理速度慢 只能按文件名清理 由于git filter-branch实现上的缺陷，第三方的重写历史工具应此而生，如BFG Repo Cleaner和git filter-repo。这两个工具应该都可以满足我们的需求，不过由于git官方教程推荐了后者，故决定选取git filter-repo。\n2.1 git filter-repo的安装 2.1.1 Python和pip的安装 git filter-repo是用Python开发的工具，因此需要安装Python环境，其安装要求如下：\ngit \u003e= 2.22.0 at a minimum; some features require git \u003e= 2.24.0 or later python3 \u003e= 3.5 在https://www.python.org/downloads/release/python-384/下载安装Python 3.8.4（当然，如果是Linux环境可以直接用包管理工具安装）\npip是Python的包管理器，我们随后将用pip安装filter-repo。从Python 3.4开始，官网的安装包中已经自带了pip，在安装时用户可以直接选择安装。也可以从https://pypi.org/project/pip/#files下载pip的源码包，解压后执行\u003e\npython setup.py install 完成pip的安装。\n2.1.2 filter-repo的安装 命令行执行\npip3 install git-filter-repo 即可。\n2.2 滤除目录 在MyLib目录中，执行\ngit filter-repo --path MyLibTest/assets --invert-paths 即可滤除MyLibTest/assets在历史中的记录。其中--path用于指定目录，--invert-paths说明指定的目录需要从历史中滤除。\n关于git filter-repo的详细使用，参见git-filter-repo Manual Page\n2.3 重写推送仓库 在更改提交的历史后，需要重新推送仓库，执行\ngit push --force 即可。\n注：使用--force选项覆盖提交需要你拥有对应的权限。并且一旦操作完成，本地和远程仓库的提交历史都将被改写，操作前请确认这样是否能被接受。\n","wordCount":"158","inLanguage":"en","datePublished":"2020-07-23T10:09:23Z","dateModified":"2020-07-23T10:09:23Z","author":{"@type":"Person","name":"Qiao"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tanjoe.github.io/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git-submodule%E5%92%8Cgit-filter-repo%E4%BB%8E%E4%BB%93%E5%BA%93%E4%B8%AD%E5%88%86%E7%A6%BB%E7%89%B9%E5%AE%9A%E7%9B%AE%E5%BD%95/"},"publisher":{"@type":"Organization","name":"Qiao","logo":{"@type":"ImageObject","url":"https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tanjoe.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://tanjoe.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tanjoe.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://tanjoe.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tanjoe.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tanjoe.github.io/posts/>Posts</a></div><h1 class=post-title>如何使用git submodule和git filter-repo从仓库中分离特定目录</h1><div class=post-meta><span title='2020-07-23 10:09:23 +0000 UTC'>2020-07-23</span>&nbsp;·&nbsp;Qiao</div></header><div class=post-content><p>碰到了一个这样的场景：同事为了单元测试，将众多测试资源文件提交到了git仓库内，这导致仓库体积陡然膨胀。但另一方面，编写好的测试用例又确实依赖这些测试资源文件。那么，有没有办法能达到以下目标：</p><ul><li>分离工程文件和测试资源，以便能够单独管理二者</li><li>清洗提交记录，将测试资源在提交历史中“抹去”，以便减小仓库的体积</li></ul><p>搜索一番，发现了<code>git submodule</code>和<code>git filter-repo</code>两个工具刚好可以满足这两个需求。</p><h2 id=1--git-submodule的使用>1 <code>git submodule</code>的使用<a hidden class=anchor aria-hidden=true href=#1--git-submodule的使用>#</a></h2><p><code>submodule</code>是git自带的一个工具，详细的介绍参见<a href=https://git-scm.com/book/zh/v2/Git-%e5%b7%a5%e5%85%b7-%e5%ad%90%e6%a8%a1%e5%9d%97>Git-工具-子模块</a>，这里不再赘述，只简单说明如何利用<code>git submodule</code>满足上述需求。</p><h3 id=11-从仓库中移除测试资源>1.1 从仓库中移除测试资源<a hidden class=anchor aria-hidden=true href=#11-从仓库中移除测试资源>#</a></h3><p>假设工程结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>├─MyLib
</span></span><span class=line><span class=cl>│  ├─include
</span></span><span class=line><span class=cl>│  └─src
</span></span><span class=line><span class=cl>├─MyLibTest
</span></span><span class=line><span class=cl>   ├─assets
</span></span><span class=line><span class=cl>   └─src
</span></span></code></pre></div><p>其中<code>MyLib</code>为库的工程，而<code>MyLibTest</code>则是<code>MyLib</code>的单元测试工程，测试资源存放在<code>MyLibTest/assets</code>下，也正是我们需要移除的目录。</p><p>首先，在git bash中执行</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git rm -r --cached MyLibTest/assets
</span></span></code></pre></div><p>将<code>MyLibTest/assets</code>从git仓库索引中移除，但不实际删除该目录。</p><blockquote><p>关于<code>git rm</code>的使用，参见<a href=https://git-scm.com/docs/git-rm>git-rm</a></p></blockquote><h3 id=12-新建测试资源仓库>1.2 新建测试资源仓库<a hidden class=anchor aria-hidden=true href=#12-新建测试资源仓库>#</a></h3><h4 id=新建远程仓库>新建远程仓库<a hidden class=anchor aria-hidden=true href=#新建远程仓库>#</a></h4><p>在git服务器上新建一个仓库，记作<code>MyLibTestResource</code>，用于存放测试资源。</p><h4 id=新建本地仓库>新建本地仓库<a hidden class=anchor aria-hidden=true href=#新建本地仓库>#</a></h4><p>新建一个目录，这里记作<code>TestResource</code>，在其中建立git仓库，将<code>MyLibTest/assets</code>中的内容复制到该目录下，随后提交。再执行</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git remote add origin git@MyLibTestResource.git <span class=c1>#git@MyLibTestResource.git替换为MyLibTestResource的真实git地址</span>
</span></span></code></pre></div><p>添加远程仓库，随后执行<code>git push</code>推送即可。</p><h3 id=13-添加子模块>1.3 添加子模块<a hidden class=anchor aria-hidden=true href=#13-添加子模块>#</a></h3><p>回到<code>MyLib</code>下，执行</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git submodule add git@MyLibTestResource.git MyLibTest/assets
</span></span></code></pre></div><p>添加子模块<code>MyLibTestResource</code>，子模块的内容会同步到<code>MyLibTest/assets</code>下。</p><h3 id=14-克隆包含子模块的项目>1.4 克隆包含子模块的项目<a hidden class=anchor aria-hidden=true href=#14-克隆包含子模块的项目>#</a></h3><p>克隆包含子模块的项目有二种方法：一种是先克隆父项目，再更新子模块；另一种是直接递归克隆整个项目。</p><h4 id=克隆父项目再更新子模块>克隆父项目，再更新子模块<a hidden class=anchor aria-hidden=true href=#克隆父项目再更新子模块>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#克隆父项目MyLib</span>
</span></span><span class=line><span class=cl>git clone git@MyLib.git <span class=c1>#git@MyLib.git替换为MyLib的真实git地址</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#初始化子模块</span>
</span></span><span class=line><span class=cl><span class=nb>cd</span> MyLib
</span></span><span class=line><span class=cl>git submodule init
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#更新子模块</span>
</span></span><span class=line><span class=cl>git submodule update
</span></span></code></pre></div><h4 id=递归克隆整个项目>递归克隆整个项目<a hidden class=anchor aria-hidden=true href=#递归克隆整个项目>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git clone git@MyLib.git --recursive
</span></span></code></pre></div><h2 id=2--git-filter-repo的使用>2 <code>git filter-repo</code>的使用<a hidden class=anchor aria-hidden=true href=#2--git-filter-repo的使用>#</a></h2><p>利用<code>git submodule</code>可以将测试资源从<code>MyLib</code>中分离，但<code>MyLib</code>仓库中仍然记录着测试资源的提交与更改，这导致仓库体积仍然很庞大。那么，如何改写git提交历史，将测试资源相关的提交与更改从历史中“抹去”呢？</p><p>对于重写历史，我们已有<code>git commit --amend</code>、<code>git rebase</code>等工具可用，但这些指令都只适用于一个或几个提交的修改，修改大量提交时用这些指令会显得非常繁琐。Git还提供了一个<code>git filter-branch</code>用于改写历史中的大量提交，不过很可惜，它至少有以下缺陷：</p><ul><li>清理速度慢</li><li>只能按文件名清理</li></ul><p>由于<code>git filter-branch</code>实现上的缺陷，第三方的重写历史工具应此而生，如<a href=https://rtyley.github.io/bfg-repo-cleaner/>BFG Repo Cleaner</a>和<a href=https://github.com/newren/git-filter-repo>git filter-repo</a>。这两个工具应该都可以满足我们的需求，不过由于git官方教程推荐了后者，故决定选取<code>git filter-repo</code>。</p><h3 id=21-git-filter-repo的安装>2.1 <code>git filter-repo</code>的安装<a hidden class=anchor aria-hidden=true href=#21-git-filter-repo的安装>#</a></h3><h4 id=211-python和pip的安装>2.1.1 Python和pip的安装<a hidden class=anchor aria-hidden=true href=#211-python和pip的安装>#</a></h4><p><code>git filter-repo</code>是用Python开发的工具，因此需要安装Python环境，其安装要求如下：</p><blockquote><ul><li>git >= 2.22.0 at a minimum; <a href=https://github.com/newren/git-filter-repo#upstream-improvements>some features</a> require git >= 2.24.0 or later</li><li>python3 >= 3.5</li></ul></blockquote><p>在<a href=https://www.python.org/downloads/release/python-384/%e4%b8%8b%e8%bd%bd%e5%ae%89%e8%a3%85Python>https://www.python.org/downloads/release/python-384/下载安装Python</a> 3.8.4（当然，如果是Linux环境可以直接用包管理工具安装）</p><p><code>pip</code>是Python的包管理器，我们随后将用<code>pip</code>安装<code>filter-repo</code>。从Python 3.4开始，官网的安装包中已经自带了<code>pip</code>，在安装时用户可以直接选择安装。也可以从<a href=https://pypi.org/project/pip/#files%e4%b8%8b%e8%bd%bd>https://pypi.org/project/pip/#files下载</a><code>pip</code>的源码包，解压后执行></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>python setup.py install
</span></span></code></pre></div><p>完成<code>pip</code>的安装。</p><h4 id=212-filter-repo的安装>2.1.2 filter-repo的安装<a hidden class=anchor aria-hidden=true href=#212-filter-repo的安装>#</a></h4><p>命令行执行</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>pip3 install git-filter-repo
</span></span></code></pre></div><p>即可。</p><h3 id=22-滤除目录>2.2 滤除目录<a hidden class=anchor aria-hidden=true href=#22-滤除目录>#</a></h3><p>在<code>MyLib</code>目录中，执行</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git filter-repo --path MyLibTest/assets --invert-paths
</span></span></code></pre></div><p>即可滤除<code>MyLibTest/assets</code>在历史中的记录。其中<code>--path</code>用于指定目录，<code>--invert-paths</code>说明指定的目录需要从历史中滤除。</p><blockquote><p>关于<code>git filter-repo</code>的详细使用，参见<a href=https://htmlpreview.github.io/?https://github.com/newren/git-filter-repo/blob/docs/html/git-filter-repo.html>git-filter-repo Manual Page</a></p></blockquote><h3 id=23-重写推送仓库>2.3 重写推送仓库<a hidden class=anchor aria-hidden=true href=#23-重写推送仓库>#</a></h3><p>在更改提交的历史后，需要重新推送仓库，执行</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git push --force
</span></span></code></pre></div><p>即可。</p><p>注：使用<code>--force</code>选项覆盖提交需要你拥有对应的权限。并且一旦操作完成，本地和远程仓库的提交历史都将被改写，<strong>操作前请确认这样是否能被接受</strong>。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tanjoe.github.io/tags/git/>git</a></li></ul><nav class=paginav><a class=prev href=https://tanjoe.github.io/posts/%E5%9C%A8windows%E4%B8%8A%E7%BC%96%E8%AF%91vtk-9-0-1%E5%8F%8A%E5%85%B6%E7%A4%BA%E4%BE%8B/><span class=title>« Prev</span><br><span>在Windows上编译VTK-9-0-1及其示例</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://tanjoe.github.io/>Qiao</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>