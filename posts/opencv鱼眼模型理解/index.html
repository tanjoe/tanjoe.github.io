<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OpenCV鱼眼模型理解 | Qiao</title><meta name=keywords content="ComputerVision,Calibration,Camera"><meta name=description content="鱼眼模型介绍 这里直接截取鱼眼镜头的成像原理到畸变矫正的原文作为此文的引子：
鱼眼镜头一般是由十几个不同的透镜组合而成的。在成像的过程中，入射光线经过不同程度的折射，投影到尺寸有限的成像平面上，使得鱼眼镜头与普通镜头相比起来拥有了更大的视野范围。
在研究鱼眼相机成像时，可以将上面的镜头组简化为一个球面：
图中，$O_1-X_cY_cZ_c$是相机坐标系，$O_2-xy$是成像平面。世界中有一点$P$，入射角为$\theta$。如果按照针孔相机模型，入射光线$PO_1$经过镜头后不改变路线，$p&rsquo;$为$P$的成像点。但对于鱼眼相机，入射光线经过镜头后会发生折射，因此$p$才是$P$的成像点，极坐标表示为$(r, \varphi)$ 。
可以用投影函数来对光线的折射建模。根据投影函数的不同，鱼眼相机的传统模型大致能被分为五种：透视投影（即针孔相机模型）、等积投影、等距投影、体视投影、正交投影。
投影模型 投影函数 特征 i. 透视投影 (perspective projection) $r = ftan\theta$ 针孔相机模型 ii. 体视投影 (stereographic projection) $r = 2ftan\frac \theta 2$​ 任何直线相交的角度，在变换后保持不变 iii. 等距投影 (equidistance projection) $r = f\theta$ 物体成像面上距离画面中心的距离与入射角成正比 iv. 等积投影 (equisolid angle projection) $r = 2fsin\frac \theta 2$​ 在变换前后，物体所占的立体角大小不变 v. 正交投影 (orthogonal projection) $r = fsin\theta$ 投影畸变最大，而且最大视场角不能大于180° OpenCV所用模型 先看OpenCV文档的原文：
Let $P$ be a point in 3D of coordinates X in the world reference frame (stored in the matrix X) The coordinate vector of $P$ in the camera reference frame is:"><meta name=author content="Qiao"><link rel=canonical href=https://tanjoe.github.io/posts/opencv%E9%B1%BC%E7%9C%BC%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"forest",themeVariables:{lineColor:"#fafafa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><meta property="og:title" content="OpenCV鱼眼模型理解"><meta property="og:description" content="鱼眼模型介绍 这里直接截取鱼眼镜头的成像原理到畸变矫正的原文作为此文的引子：
鱼眼镜头一般是由十几个不同的透镜组合而成的。在成像的过程中，入射光线经过不同程度的折射，投影到尺寸有限的成像平面上，使得鱼眼镜头与普通镜头相比起来拥有了更大的视野范围。
在研究鱼眼相机成像时，可以将上面的镜头组简化为一个球面：
图中，$O_1-X_cY_cZ_c$是相机坐标系，$O_2-xy$是成像平面。世界中有一点$P$，入射角为$\theta$。如果按照针孔相机模型，入射光线$PO_1$经过镜头后不改变路线，$p&rsquo;$为$P$的成像点。但对于鱼眼相机，入射光线经过镜头后会发生折射，因此$p$才是$P$的成像点，极坐标表示为$(r, \varphi)$ 。
可以用投影函数来对光线的折射建模。根据投影函数的不同，鱼眼相机的传统模型大致能被分为五种：透视投影（即针孔相机模型）、等积投影、等距投影、体视投影、正交投影。
投影模型 投影函数 特征 i. 透视投影 (perspective projection) $r = ftan\theta$ 针孔相机模型 ii. 体视投影 (stereographic projection) $r = 2ftan\frac \theta 2$​ 任何直线相交的角度，在变换后保持不变 iii. 等距投影 (equidistance projection) $r = f\theta$ 物体成像面上距离画面中心的距离与入射角成正比 iv. 等积投影 (equisolid angle projection) $r = 2fsin\frac \theta 2$​ 在变换前后，物体所占的立体角大小不变 v. 正交投影 (orthogonal projection) $r = fsin\theta$ 投影畸变最大，而且最大视场角不能大于180° OpenCV所用模型 先看OpenCV文档的原文：
Let $P$ be a point in 3D of coordinates X in the world reference frame (stored in the matrix X) The coordinate vector of $P$ in the camera reference frame is:"><meta property="og:type" content="article"><meta property="og:url" content="https://tanjoe.github.io/posts/opencv%E9%B1%BC%E7%9C%BC%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3/"><meta property="og:image" content="https://tanjoe.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-10T17:38:38+00:00"><meta property="article:modified_time" content="2023-05-10T17:38:38+00:00"><meta property="og:site_name" content="Qiao"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tanjoe.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="OpenCV鱼眼模型理解"><meta name=twitter:description content="鱼眼模型介绍 这里直接截取鱼眼镜头的成像原理到畸变矫正的原文作为此文的引子：
鱼眼镜头一般是由十几个不同的透镜组合而成的。在成像的过程中，入射光线经过不同程度的折射，投影到尺寸有限的成像平面上，使得鱼眼镜头与普通镜头相比起来拥有了更大的视野范围。
在研究鱼眼相机成像时，可以将上面的镜头组简化为一个球面：
图中，$O_1-X_cY_cZ_c$是相机坐标系，$O_2-xy$是成像平面。世界中有一点$P$，入射角为$\theta$。如果按照针孔相机模型，入射光线$PO_1$经过镜头后不改变路线，$p&rsquo;$为$P$的成像点。但对于鱼眼相机，入射光线经过镜头后会发生折射，因此$p$才是$P$的成像点，极坐标表示为$(r, \varphi)$ 。
可以用投影函数来对光线的折射建模。根据投影函数的不同，鱼眼相机的传统模型大致能被分为五种：透视投影（即针孔相机模型）、等积投影、等距投影、体视投影、正交投影。
投影模型 投影函数 特征 i. 透视投影 (perspective projection) $r = ftan\theta$ 针孔相机模型 ii. 体视投影 (stereographic projection) $r = 2ftan\frac \theta 2$​ 任何直线相交的角度，在变换后保持不变 iii. 等距投影 (equidistance projection) $r = f\theta$ 物体成像面上距离画面中心的距离与入射角成正比 iv. 等积投影 (equisolid angle projection) $r = 2fsin\frac \theta 2$​ 在变换前后，物体所占的立体角大小不变 v. 正交投影 (orthogonal projection) $r = fsin\theta$ 投影畸变最大，而且最大视场角不能大于180° OpenCV所用模型 先看OpenCV文档的原文：
Let $P$ be a point in 3D of coordinates X in the world reference frame (stored in the matrix X) The coordinate vector of $P$ in the camera reference frame is:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tanjoe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"OpenCV鱼眼模型理解","item":"https://tanjoe.github.io/posts/opencv%E9%B1%BC%E7%9C%BC%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OpenCV鱼眼模型理解","name":"OpenCV鱼眼模型理解","description":"鱼眼模型介绍 这里直接截取鱼眼镜头的成像原理到畸变矫正的原文作为此文的引子：\n鱼眼镜头一般是由十几个不同的透镜组合而成的。在成像的过程中，入射光线经过不同程度的折射，投影到尺寸有限的成像平面上，使得鱼眼镜头与普通镜头相比起来拥有了更大的视野范围。\n在研究鱼眼相机成像时，可以将上面的镜头组简化为一个球面：\n图中，$O_1-X_cY_cZ_c$是相机坐标系，$O_2-xy$是成像平面。世界中有一点$P$，入射角为$\\theta$。如果按照针孔相机模型，入射光线$PO_1$经过镜头后不改变路线，$p\u0026rsquo;$为$P$的成像点。但对于鱼眼相机，入射光线经过镜头后会发生折射，因此$p$才是$P$的成像点，极坐标表示为$(r, \\varphi)$ 。\n可以用投影函数来对光线的折射建模。根据投影函数的不同，鱼眼相机的传统模型大致能被分为五种：透视投影（即针孔相机模型）、等积投影、等距投影、体视投影、正交投影。\n投影模型 投影函数 特征 i. 透视投影 (perspective projection) $r = ftan\\theta$ 针孔相机模型 ii. 体视投影 (stereographic projection) $r = 2ftan\\frac \\theta 2$​ 任何直线相交的角度，在变换后保持不变 iii. 等距投影 (equidistance projection) $r = f\\theta$ 物体成像面上距离画面中心的距离与入射角成正比 iv. 等积投影 (equisolid angle projection) $r = 2fsin\\frac \\theta 2$​ 在变换前后，物体所占的立体角大小不变 v. 正交投影 (orthogonal projection) $r = fsin\\theta$ 投影畸变最大，而且最大视场角不能大于180° OpenCV所用模型 先看OpenCV文档的原文：\nLet $P$ be a point in 3D of coordinates X in the world reference frame (stored in the matrix X) The coordinate vector of $P$ in the camera reference frame is:","keywords":["ComputerVision","Calibration","Camera"],"articleBody":"鱼眼模型介绍 这里直接截取鱼眼镜头的成像原理到畸变矫正的原文作为此文的引子：\n鱼眼镜头一般是由十几个不同的透镜组合而成的。在成像的过程中，入射光线经过不同程度的折射，投影到尺寸有限的成像平面上，使得鱼眼镜头与普通镜头相比起来拥有了更大的视野范围。\n在研究鱼眼相机成像时，可以将上面的镜头组简化为一个球面：\n图中，$O_1-X_cY_cZ_c$是相机坐标系，$O_2-xy$是成像平面。世界中有一点$P$，入射角为$\\theta$。如果按照针孔相机模型，入射光线$PO_1$经过镜头后不改变路线，$p’$为$P$的成像点。但对于鱼眼相机，入射光线经过镜头后会发生折射，因此$p$才是$P$的成像点，极坐标表示为$(r, \\varphi)$ 。\n可以用投影函数来对光线的折射建模。根据投影函数的不同，鱼眼相机的传统模型大致能被分为五种：透视投影（即针孔相机模型）、等积投影、等距投影、体视投影、正交投影。\n投影模型 投影函数 特征 i. 透视投影 (perspective projection) $r = ftan\\theta$ 针孔相机模型 ii. 体视投影 (stereographic projection) $r = 2ftan\\frac \\theta 2$​ 任何直线相交的角度，在变换后保持不变 iii. 等距投影 (equidistance projection) $r = f\\theta$ 物体成像面上距离画面中心的距离与入射角成正比 iv. 等积投影 (equisolid angle projection) $r = 2fsin\\frac \\theta 2$​ 在变换前后，物体所占的立体角大小不变 v. 正交投影 (orthogonal projection) $r = fsin\\theta$ 投影畸变最大，而且最大视场角不能大于180° OpenCV所用模型 先看OpenCV文档的原文：\nLet $P$ be a point in 3D of coordinates X in the world reference frame (stored in the matrix X) The coordinate vector of $P$ in the camera reference frame is:\n$Xc = R X + T$\nwhere $R$ is the rotation matrix corresponding to the rotation vector om: $R$ = rodrigues(om); call x, y and z the 3 coordinates of $Xc$:\n$x=Xc_1$\n$y=Xc_2$\n$z=Xc_3$\nThe pinhole projection coordinates of P is $[a; b]$ where\n$a=x/z$\n$b=y/z$\n$r^2=a^2+b^2$\n$θ=arctan(r)$\nFisheye distortion:\n$θ_d=θ(1+k_1θ^2+k_2θ^4+k_3θ^6+k_4θ^8)$\nThe distorted point coordinates are $[x’; y’]$ where\n$x′=(θ_d/r)a$\n$y′=(θ_d/r)b$\nFinally, conversion into pixel coordinates: The final pixel coordinates vector $[u; v]$ where:\n$u = f_x (x’ + \\alpha y’) + c_x$\n$v = f_y y’ + c_y$\n查看cv2::fisheye::initUndistortRectifyMap的实现，和文档描述的一致：\nvoid cv::fisheye::initUndistortRectifyMap( InputArray K, InputArray D, InputArray R, InputArray P, const cv::Size\u0026 size, int m1type, OutputArray map1, OutputArray map2 ) { // ... for( int i = 0; i \u003c size.height; ++i) { // ... for( int j = 0; j \u003c size.width; ++j) { double u, v; if( _w \u003c= 0) { u = (_x \u003e 0) ? -std::numeric_limits\u003cdouble\u003e::infinity() : std::numeric_limits\u003cdouble\u003e::infinity(); v = (_y \u003e 0) ? -std::numeric_limits\u003cdouble\u003e::infinity() : std::numeric_limits\u003cdouble\u003e::infinity(); } else { double x = _x/_w, y = _y/_w; double r = sqrt(x*x + y*y); double theta = atan(r); double theta2 = theta*theta, theta4 = theta2*theta2, theta6 = theta4*theta2, theta8 = theta4*theta4; double theta_d = theta * (1 + k[0]*theta2 + k[1]*theta4 + k[2]*theta6 + k[3]*theta8); double scale = (r == 0) ? 1.0 : theta_d / r; u = f[0]*x*scale + c[0]; v = f[1]*y*scale + c[1]; } // ... } } } 探讨 现在问题来了，\n$\\theta=arctan(r)$是怎么来的？ 实际是$\\theta = arctan(r/f)$。由于建模时用的是归一化的球面和像平面，故$f$为1\n$u = f_x (x’ + \\alpha y’) + c_x$里的$\\alpha$是什么？ $\\alpha$为skew coefficient。“skew\"指成像平面x轴和y轴的角度。理想的成像平面x轴和y轴是垂直的，但现实中x轴和y轴可能是倾斜的，进而产生倾斜的图片。为了纠正此偏差，需要对图片施加一个仿射变化。由于大部分厂商的CCD是直角的，故用OpenCV标定时会使用CALIB_FIX_SKEW的flag，$\\alpha$设为0\n$θ_d=θ(1+k_1θ^2+k_2θ^4+k_3θ^6+k_4θ^8)$是怎么来的？ 按照论文《A Generic Camera Model and Calibration Method for Conventional, Wide-Angle, and Fish-Eye Lenses》，为了方便鱼眼相机的标定，一般取$r$关于$\\theta$泰勒展开式的前5项来近似鱼眼镜头的实际投影函数，即\n$r_d \\approx θ(1+k_1θ^2+k_2θ^4+k_3θ^6+k_4θ^8)$\n那么，这里为什么是$\\theta_d$而非$r_d$？\n解释一 鱼眼镜头的成像原理到畸变矫正一文给出下图，并作解释\n由几何关系有\n$r_d = f * tan(\\theta_d) = tan(\\theta_d)$\n考虑到相机的成像CCD平面尺寸一般都是几毫米，焦距在几百毫米左右，所以相机实际成像过程中$\\theta_d$通常很小，此时$tan(\\theta_d) \\approx \\theta_d$，故有\n$r_d = tan(\\theta_d) = \\theta_d = θ(1+k_1θ^2+k_2θ^4+k_3θ^6+k_4θ^8)$\n问题是，推导模型时用的是归一化的球面和成像平面，$\\theta_d$并不总是很小。比如，当$(x’,y’)=(1,1)$时，$r_d=\\sqrt2$，$\\theta_d=arctan(r_d)\\approx0.955$，此时将$\\theta_d$近似为$tan(\\theta_d)$并不合理。\n解释二 鱼眼投影模型理解以及opencv官方文档和同类文章勘误 - 知乎给出的解释则是，\nOpenCV文档里的$\\theta_d$并不是折射角，对应的实际是图中的$r_d$，这只是一个误导性的变量名称。\n解释三 结合Stack Overflow的讨论，我的解释是，$\\theta_d$指的就是用多项式修正后的入射角，而非折射角，也不是成像点在像平面上的极坐标半径（尽管后面会看到它们数值相等）。OpenCV对鱼眼成像的建模过程如下：\n对于世界坐标系中任一点$P$，计算其在针孔相机坐标系中的投影坐标$[a, b]$，再计算出该点在相机坐标系极坐标半径$r$和入射角$\\theta$ 实际很少有perfect angular fisheye lenses，镜头会有一定非线性的存在。考虑到这一点，将入射角修正为$\\theta_d = \\theta (1 + k_1 \\theta^2 + k_2 \\theta^4 + k_3 \\theta^6 + k_4 \\theta^8)$ 采用等距投影模型（$r=f\\theta_d$），将相机坐标系的点投影到图像平面。有$x’=(\\theta_d/r)a$, $y’=(\\theta_d/r)b$ 在归一化球面和像平面上，$f=1$，故同样有$r=\\theta_d=\\theta (1 + k_1 \\theta^2 + k_2 \\theta^4 + k_3 \\theta^6 + k_4 \\theta^8)$ 从结果上看，此种解释和解释二是等效的。\n事实上，无论是像此种解释一样将投影、畸变分开处理，还是像解释二一样将整个过程用一个多项式拟合，都是可行的。\n记投影函数为$P(\\theta)$，多项式畸变函数为$D(\\theta)$，如果将投影-畸变视为独立的过程，那过程函数是$r=P(D(\\theta))$，而$P(D(\\theta))$完全可以用另一个多项式$E(\\theta)$拟合，即$r=P(D(\\theta))=E(\\theta)$。$D$和$E$都是多项式函数，只不过其系数随$P$的具体形式可能完全相同（等距投影），也有可能不同（其它非线性投影）。\n至于鱼眼镜头的成像原理到畸变矫正给出的图，\n如果对照此图，很容易认为$\\theta_d$是折射角而非入射角，且可以进而推出$r_d=ftan\\theta_d$，这岂不是与上面用的等距投影$r=f\\theta_d$矛盾？\n我的看法是，这张图与OpenCV的投影模型无关，如果硬按照此图理解OpenCV的鱼眼模型，当然是会产生矛盾的。OpenCV文档本身没有给出示意图，按个人理解，其过程及所用符号的含义更接近论文的原图，这里我额外标记了$\\theta_d$：\n由于$\\theta_d$并非折射角，所以$r_d=ftan\\theta_d$自然也是不成立的。\n当FOV\u003e180°时，此模型还成立吗？ 从OpenCV Fisheye Calibration FOV 220 - Python - OpenCV及Calibrating fisheye lenses above 180 degrees - OpenCV Q\u0026A Forum的讨论来看，OpenCV当前是不支持超过180°FOV鱼眼的标定的\n总结 综上，我理解OpenCV的鱼眼模型其实是等距投影模型+多项式畸变模型。\n参考 OpenCV: Fisheye camera model 鱼眼镜头的成像原理到畸变矫正 鱼眼投影模型理解以及opencv官方文档和同类文章勘误 - 知乎 A generic camera model and calibration method for conventional, wide-angle, and fish-eye lenses | IEEE Journals \u0026 Magazine | IEEE Xplore Fisheye lens correction c++ - What are the main references to the fish-eye camera model in OpenCV3.0.0dev? - Stack Overflow ","wordCount":"504","inLanguage":"en","datePublished":"2023-05-10T17:38:38Z","dateModified":"2023-05-10T17:38:38Z","author":{"@type":"Person","name":"Qiao"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tanjoe.github.io/posts/opencv%E9%B1%BC%E7%9C%BC%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3/"},"publisher":{"@type":"Organization","name":"Qiao","logo":{"@type":"ImageObject","url":"https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tanjoe.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://tanjoe.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tanjoe.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://tanjoe.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tanjoe.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tanjoe.github.io/posts/>Posts</a></div><h1 class=post-title>OpenCV鱼眼模型理解</h1><div class=post-meta><span title='2023-05-10 17:38:38 +0000 UTC'>2023-05-10</span>&nbsp;·&nbsp;Qiao</div></header><div class=post-content><h2 id=鱼眼模型介绍>鱼眼模型介绍<a hidden class=anchor aria-hidden=true href=#鱼眼模型介绍>#</a></h2><p>这里直接截取<a href=https://blog.csdn.net/qq_16137569/article/details/112398976>鱼眼镜头的成像原理到畸变矫正</a>的原文作为此文的引子：</p><blockquote><p>鱼眼镜头一般是由十几个不同的透镜组合而成的。在成像的过程中，入射光线经过不同程度的折射，投影到尺寸有限的成像平面上，使得鱼眼镜头与普通镜头相比起来拥有了更大的视野范围。</p><p><img src=/posts/media/Pasted%20image%2020230510175444.png></p><p>在研究鱼眼相机成像时，可以将上面的镜头组简化为一个球面：</p><p><img src=/posts/media/Pasted%20image%2020230510175600.png></p><p>图中，$O_1-X_cY_cZ_c$是相机坐标系，$O_2-xy$是成像平面。世界中有一点$P$，入射角为$\theta$。如果按照针孔相机模型，入射光线$PO_1$经过镜头后不改变路线，$p&rsquo;$为$P$的成像点。但对于鱼眼相机，入射光线经过镜头后会发生折射，因此$p$才是$P$的成像点，极坐标表示为$(r, \varphi)$ 。</p></blockquote><p>可以用投影函数来对光线的折射建模。根据投影函数的不同，鱼眼相机的传统模型大致能被分为五种：透视投影（即针孔相机模型）、等积投影、等距投影、体视投影、正交投影。</p><table><thead><tr><th>投影模型</th><th>投影函数</th><th>特征</th></tr></thead><tbody><tr><td>i. 透视投影 (perspective projection)</td><td>$r = ftan\theta$</td><td>针孔相机模型</td></tr><tr><td>ii. 体视投影 (stereographic projection)</td><td>$r = 2ftan\frac \theta 2$​</td><td>任何直线相交的角度，在变换后保持不变</td></tr><tr><td>iii. 等距投影 (equidistance projection)</td><td>$r = f\theta$</td><td>物体成像面上距离画面中心的距离与入射角成正比</td></tr><tr><td>iv. 等积投影 (equisolid angle projection)</td><td>$r = 2fsin\frac \theta 2$​</td><td>在变换前后，物体所占的立体角大小不变</td></tr><tr><td>v. 正交投影 (orthogonal projection)</td><td>$r = fsin\theta$</td><td>投影畸变最大，而且最大视场角不能大于180°</td></tr></tbody></table><h2 id=opencv所用模型>OpenCV所用模型<a hidden class=anchor aria-hidden=true href=#opencv所用模型>#</a></h2><p>先看OpenCV文档的原文：</p><blockquote><p>Let $P$ be a point in 3D of coordinates X in the world reference frame (stored in the matrix X) The coordinate vector of $P$ in the camera reference frame is:</p><p>$Xc = R X + T$</p><p>where $R$ is the rotation matrix corresponding to the rotation vector om: $R$ = rodrigues(om); call x, y and z the 3 coordinates of $Xc$:</p><p>$x=Xc_1$</p><p>$y=Xc_2$</p><p>$z=Xc_3$</p><p>The pinhole projection coordinates of P is $[a; b]$ where</p><p>$a=x/z$</p><p>$b=y/z$</p><p>$r^2=a^2+b^2$</p><p>$θ=arctan(r)$</p><p>Fisheye distortion:</p><p>$θ_d=θ(1+k_1θ^2+k_2θ^4+k_3θ^6+k_4θ^8)$</p><p>The distorted point coordinates are $[x&rsquo;; y&rsquo;]$ where</p><p>$x′=(θ_d/r)a$</p><p>$y′=(θ_d/r)b$</p><p>Finally, conversion into pixel coordinates: The final pixel coordinates vector $[u; v]$ where:</p><p>$u = f_x (x&rsquo; + \alpha y&rsquo;) + c_x$</p><p>$v = f_y y&rsquo; + c_y$</p></blockquote><p>查看<code>cv2::fisheye::initUndistortRectifyMap</code>的实现，和文档描述的一致：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>cv</span><span class=o>::</span><span class=n>fisheye</span><span class=o>::</span><span class=n>initUndistortRectifyMap</span><span class=p>(</span> <span class=n>InputArray</span> <span class=n>K</span><span class=p>,</span> <span class=n>InputArray</span> <span class=n>D</span><span class=p>,</span> <span class=n>InputArray</span> <span class=n>R</span><span class=p>,</span> <span class=n>InputArray</span> <span class=n>P</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>cv</span><span class=o>::</span><span class=n>Size</span><span class=o>&amp;</span> <span class=n>size</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m1type</span><span class=p>,</span> <span class=n>OutputArray</span> <span class=n>map1</span><span class=p>,</span> <span class=n>OutputArray</span> <span class=n>map2</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span><span class=p>(</span> <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>.</span><span class=n>height</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span><span class=p>(</span> <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>.</span><span class=n>width</span><span class=p>;</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>double</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span> <span class=n>_w</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>u</span> <span class=o>=</span> <span class=p>(</span><span class=n>_x</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=o>?</span> <span class=o>-</span><span class=n>std</span><span class=o>::</span><span class=n>numeric_limits</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;::</span><span class=n>infinity</span><span class=p>()</span> <span class=o>:</span> <span class=n>std</span><span class=o>::</span><span class=n>numeric_limits</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;::</span><span class=n>infinity</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=n>v</span> <span class=o>=</span> <span class=p>(</span><span class=n>_y</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=o>?</span> <span class=o>-</span><span class=n>std</span><span class=o>::</span><span class=n>numeric_limits</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;::</span><span class=n>infinity</span><span class=p>()</span> <span class=o>:</span> <span class=n>std</span><span class=o>::</span><span class=n>numeric_limits</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;::</span><span class=n>infinity</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>double</span> <span class=n>x</span> <span class=o>=</span> <span class=n>_x</span><span class=o>/</span><span class=n>_w</span><span class=p>,</span> <span class=n>y</span> <span class=o>=</span> <span class=n>_y</span><span class=o>/</span><span class=n>_w</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=kt>double</span> <span class=n>r</span> <span class=o>=</span> <span class=n>sqrt</span><span class=p>(</span><span class=n>x</span><span class=o>*</span><span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=o>*</span><span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=kt>double</span> <span class=n>theta</span> <span class=o>=</span> <span class=n>atan</span><span class=p>(</span><span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=kt>double</span> <span class=n>theta2</span> <span class=o>=</span> <span class=n>theta</span><span class=o>*</span><span class=n>theta</span><span class=p>,</span> <span class=n>theta4</span> <span class=o>=</span> <span class=n>theta2</span><span class=o>*</span><span class=n>theta2</span><span class=p>,</span> <span class=n>theta6</span> <span class=o>=</span> <span class=n>theta4</span><span class=o>*</span><span class=n>theta2</span><span class=p>,</span> <span class=n>theta8</span> <span class=o>=</span> <span class=n>theta4</span><span class=o>*</span><span class=n>theta4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=kt>double</span> <span class=n>theta_d</span> <span class=o>=</span> <span class=n>theta</span> <span class=o>*</span> <span class=p>(</span><span class=mi>1</span> <span class=o>+</span> <span class=n>k</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>*</span><span class=n>theta2</span> <span class=o>+</span> <span class=n>k</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>*</span><span class=n>theta4</span> <span class=o>+</span> <span class=n>k</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=o>*</span><span class=n>theta6</span> <span class=o>+</span> <span class=n>k</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span><span class=o>*</span><span class=n>theta8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=kt>double</span> <span class=n>scale</span> <span class=o>=</span> <span class=p>(</span><span class=n>r</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>?</span> <span class=mf>1.0</span> <span class=o>:</span> <span class=n>theta_d</span> <span class=o>/</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>u</span> <span class=o>=</span> <span class=n>f</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>*</span><span class=n>x</span><span class=o>*</span><span class=n>scale</span> <span class=o>+</span> <span class=n>c</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>v</span> <span class=o>=</span> <span class=n>f</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>*</span><span class=n>y</span><span class=o>*</span><span class=n>scale</span> <span class=o>+</span> <span class=n>c</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=探讨>探讨<a hidden class=anchor aria-hidden=true href=#探讨>#</a></h2><p>现在问题来了，</p><h3 id=thetaarctanr是怎么来的>$\theta=arctan(r)$是怎么来的？<a hidden class=anchor aria-hidden=true href=#thetaarctanr是怎么来的>#</a></h3><p>实际是$\theta = arctan(r/f)$。<strong>由于建模时用的是归一化的球面和像平面，故$f$为1</strong></p><h3 id=u--f_x-x--alpha-y--c_x里的alpha是什么>$u = f_x (x&rsquo; + \alpha y&rsquo;) + c_x$里的$\alpha$是什么？<a hidden class=anchor aria-hidden=true href=#u--f_x-x--alpha-y--c_x里的alpha是什么>#</a></h3><p>$\alpha$为skew coefficient。&ldquo;skew"指成像平面x轴和y轴的角度。理想的成像平面x轴和y轴是垂直的，但现实中x轴和y轴可能是倾斜的，进而产生倾斜的图片。为了纠正此偏差，需要对图片施加一个仿射变化。由于大部分厂商的CCD是直角的，故用OpenCV标定时会使用<code>CALIB_FIX_SKEW</code>的flag，$\alpha$设为0</p><h3 id=θ_dθ1k_1θ2k_2θ4k_3θ6k_4θ8是怎么来的>$θ_d=θ(1+k_1θ^2+k_2θ^4+k_3θ^6+k_4θ^8)$是怎么来的？<a hidden class=anchor aria-hidden=true href=#θ_dθ1k_1θ2k_2θ4k_3θ6k_4θ8是怎么来的>#</a></h3><p>按照论文《A Generic Camera Model and Calibration Method for Conventional, Wide-Angle, and Fish-Eye Lenses》，为了方便鱼眼相机的标定，一般取$r$关于$\theta$泰勒展开式的前5项来近似鱼眼镜头的实际投影函数，即</p><p>$r_d \approx θ(1+k_1θ^2+k_2θ^4+k_3θ^6+k_4θ^8)$</p><p>那么，这里为什么是$\theta_d$而非$r_d$？</p><h4 id=解释一>解释一<a hidden class=anchor aria-hidden=true href=#解释一>#</a></h4><p><a href=https://blog.csdn.net/qq_16137569/article/details/112398976>鱼眼镜头的成像原理到畸变矫正</a>一文给出下图，并作解释</p><blockquote><p><img src=/posts/media/Pasted%20image%2020230510174502.png>
由几何关系有</p><p>$r_d = f * tan(\theta_d) = tan(\theta_d)$</p><p>考虑到相机的成像CCD平面尺寸一般都是几毫米，焦距在几百毫米左右，所以相机实际成像过程中$\theta_d$通常很小，此时$tan(\theta_d) \approx \theta_d$，故有</p><p>$r_d = tan(\theta_d) = \theta_d = θ(1+k_1θ^2+k_2θ^4+k_3θ^6+k_4θ^8)$</p></blockquote><p>问题是，推导模型时用的是归一化的球面和成像平面，$\theta_d$并不总是很小。比如，当$(x&rsquo;,y&rsquo;)=(1,1)$时，$r_d=\sqrt2$，$\theta_d=arctan(r_d)\approx0.955$，此时将$\theta_d$近似为$tan(\theta_d)$并不合理。</p><h4 id=解释二>解释二<a hidden class=anchor aria-hidden=true href=#解释二>#</a></h4><p><a href=https://zhuanlan.zhihu.com/p/456538243>鱼眼投影模型理解以及opencv官方文档和同类文章勘误 - 知乎</a>给出的解释则是，</p><blockquote><p>OpenCV文档里的$\theta_d$并不是折射角，对应的实际是图中的$r_d$，这只是一个误导性的变量名称。</p></blockquote><h4 id=解释三>解释三<a hidden class=anchor aria-hidden=true href=#解释三>#</a></h4><p>结合<a href=https://stackoverflow.com/questions/31089265/what-are-the-main-references-to-the-fish-eye-camera-model-in-opencv3-0-0dev>Stack Overflow</a>的讨论，我的解释是，$\theta_d$指的就是用多项式修正后的<strong>入射角</strong>，而非折射角，也不是成像点在像平面上的极坐标半径（尽管后面会看到它们数值相等）。OpenCV对鱼眼成像的建模过程如下：</p><ol><li>对于世界坐标系中任一点$P$，计算其在针孔相机坐标系中的投影坐标$[a, b]$，再计算出该点在相机坐标系极坐标半径$r$和入射角$\theta$</li><li>实际很少有perfect angular fisheye lenses，镜头会有一定非线性的存在。考虑到这一点，将入射角修正为$\theta_d = \theta (1 + k_1 \theta^2 + k_2 \theta^4 + k_3 \theta^6 + k_4 \theta^8)$</li><li>采用<strong>等距投影</strong>模型（$r=f\theta_d$），将相机坐标系的点投影到图像平面。有$x&rsquo;=(\theta_d/r)a$, $y&rsquo;=(\theta_d/r)b$</li><li>在归一化球面和像平面上，$f=1$，故同样有$r=\theta_d=\theta (1 + k_1 \theta^2 + k_2 \theta^4 + k_3 \theta^6 + k_4 \theta^8)$</li></ol><p>从结果上看，此种解释和解释二是等效的。</p><p>事实上，无论是像此种解释一样将投影、畸变分开处理，还是像解释二一样将整个过程用一个多项式拟合，都是可行的。</p><p>记投影函数为$P(\theta)$，多项式畸变函数为$D(\theta)$，如果将投影-畸变视为独立的过程，那过程函数是$r=P(D(\theta))$，而$P(D(\theta))$完全可以用另一个多项式$E(\theta)$拟合，即$r=P(D(\theta))=E(\theta)$。$D$和$E$都是多项式函数，只不过其系数随$P$的具体形式可能完全相同（等距投影），也有可能不同（其它非线性投影）。</p><p>至于<a href=https://blog.csdn.net/qq_16137569/article/details/112398976>鱼眼镜头的成像原理到畸变矫正</a>给出的图，</p><p><img src=/posts/media/Pasted%20image%2020230510174502.png></p><p>如果对照此图，很容易认为$\theta_d$是折射角而非入射角，且可以进而推出$r_d=ftan\theta_d$，这岂不是与上面用的等距投影$r=f\theta_d$矛盾？</p><p>我的看法是，<strong>这张图与OpenCV的投影模型无关</strong>，如果硬按照此图理解OpenCV的鱼眼模型，当然是会产生矛盾的。OpenCV文档本身没有给出示意图，按个人理解，其过程及所用符号的含义更接近论文的原图，这里我额外标记了$\theta_d$：</p><p><img src=/posts/media/Pasted%20image%2020230525112327.png></p><p>由于$\theta_d$并非折射角，所以$r_d=ftan\theta_d$自然也是不成立的。</p><h3 id=当fov180时此模型还成立吗>当FOV>180°时，此模型还成立吗？<a hidden class=anchor aria-hidden=true href=#当fov180时此模型还成立吗>#</a></h3><p>从<a href=https://forum.opencv.org/t/opencv-fisheye-calibration-fov-220/5276/2>OpenCV Fisheye Calibration FOV 220 - Python - OpenCV</a>及<a href=https://answers.opencv.org/question/65467/calibrating-fisheye-lenses-above-180-degrees/>Calibrating fisheye lenses above 180 degrees - OpenCV Q&amp;A Forum</a>的讨论来看，OpenCV当前是不支持超过180°FOV鱼眼的标定的</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>综上，我理解OpenCV的鱼眼模型其实是<strong>等距投影模型+多项式畸变模型</strong>。</p><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ul><li><a href=https://docs.opencv.org/3.4/db/d58/group__calib3d__fisheye.html>OpenCV: Fisheye camera model</a></li><li><a href=https://blog.csdn.net/qq_16137569/article/details/112398976>鱼眼镜头的成像原理到畸变矫正</a></li><li><a href=https://zhuanlan.zhihu.com/p/456538243>鱼眼投影模型理解以及opencv官方文档和同类文章勘误 - 知乎</a></li><li><a href=https://ieeexplore.ieee.org/document/1642666>A generic camera model and calibration method for conventional, wide-angle, and fish-eye lenses | IEEE Journals & Magazine | IEEE Xplore</a></li><li><a href=http://paulbourke.net/dome/fisheyecorrect/>Fisheye lens correction</a></li><li><a href=https://stackoverflow.com/questions/31089265/what-are-the-main-references-to-the-fish-eye-camera-model-in-opencv3-0-0dev>c++ - What are the main references to the fish-eye camera model in OpenCV3.0.0dev? - Stack Overflow</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://tanjoe.github.io/tags/computervision/>ComputerVision</a></li><li><a href=https://tanjoe.github.io/tags/calibration/>Calibration</a></li><li><a href=https://tanjoe.github.io/tags/camera/>Camera</a></li></ul><nav class=paginav><a class=next href=https://tanjoe.github.io/posts/airsim%E4%B8%AD%E9%92%88%E5%AD%94%E7%9B%B8%E6%9C%BA%E7%95%B8%E5%8F%98%E7%9A%84%E5%AE%9E%E7%8E%B0/><span class=title>Next »</span><br><span>AirSim中针孔相机畸变的实现</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://tanjoe.github.io/>Qiao</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>