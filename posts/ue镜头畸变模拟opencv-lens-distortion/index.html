<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>UE镜头畸变模拟：OpenCV Lens Distortion | Qiao</title><meta name=keywords content="Simulation,Unreal,ComputerVision,ComputerGraphics"><meta name=description content="出于仿真的需要，希望在Unreal中能模拟鱼眼镜头的畸变效果，看到UE官方提供了Lens Distortion和OpenCV Lens Distortion两款插件用于模拟镜头畸变，但可惜相关资料不多。UE的博文UE中的相机标定、畸变模拟与矫正 - Unreal Engine做了些介绍，但步骤却又不是很详尽，初学者如我使用时不免多绕了些路，遂写下此文。
插件介绍 这里结合UE中的相机标定、畸变模拟与矫正 - Unreal Engine的介绍，总结如下：
Lens Distortion和OpenCV Lens Distortion用的camera model是一样的，背后的原理也类似。都是根据相机畸变参数生成displacement map，以此模拟镜头畸变 Lens Distortion没有标定功能，且只包含了畸变系数的前几项 Lens Distortion通过shader生成displacement map，而OpenCV Lens Distortion通过OpenCV的API用CPU计算生成，前者效率更快。不过由于displacement map通常只生成一次，这里的效率差异不太重要 补充：什么是displacement map？
A displacement map is a type of texture that is used in 3D computer graphics to create the illusion of depth and detail on a surface without actually changing the geometry of the mesh. A displacement map is typically a grayscale image where the brightness values of each pixel correspond to the amount of displacement that should be applied to the surface at that point."><meta name=author content="Qiao"><link rel=canonical href=https://tanjoe.github.io/posts/ue%E9%95%9C%E5%A4%B4%E7%95%B8%E5%8F%98%E6%A8%A1%E6%8B%9Fopencv-lens-distortion/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"forest",themeVariables:{lineColor:"#fafafa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><meta property="og:title" content="UE镜头畸变模拟：OpenCV Lens Distortion"><meta property="og:description" content="出于仿真的需要，希望在Unreal中能模拟鱼眼镜头的畸变效果，看到UE官方提供了Lens Distortion和OpenCV Lens Distortion两款插件用于模拟镜头畸变，但可惜相关资料不多。UE的博文UE中的相机标定、畸变模拟与矫正 - Unreal Engine做了些介绍，但步骤却又不是很详尽，初学者如我使用时不免多绕了些路，遂写下此文。
插件介绍 这里结合UE中的相机标定、畸变模拟与矫正 - Unreal Engine的介绍，总结如下：
Lens Distortion和OpenCV Lens Distortion用的camera model是一样的，背后的原理也类似。都是根据相机畸变参数生成displacement map，以此模拟镜头畸变 Lens Distortion没有标定功能，且只包含了畸变系数的前几项 Lens Distortion通过shader生成displacement map，而OpenCV Lens Distortion通过OpenCV的API用CPU计算生成，前者效率更快。不过由于displacement map通常只生成一次，这里的效率差异不太重要 补充：什么是displacement map？
A displacement map is a type of texture that is used in 3D computer graphics to create the illusion of depth and detail on a surface without actually changing the geometry of the mesh. A displacement map is typically a grayscale image where the brightness values of each pixel correspond to the amount of displacement that should be applied to the surface at that point."><meta property="og:type" content="article"><meta property="og:url" content="https://tanjoe.github.io/posts/ue%E9%95%9C%E5%A4%B4%E7%95%B8%E5%8F%98%E6%A8%A1%E6%8B%9Fopencv-lens-distortion/"><meta property="og:image" content="https://tanjoe.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-28T13:43:06+00:00"><meta property="article:modified_time" content="2023-04-28T13:43:06+00:00"><meta property="og:site_name" content="Qiao"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tanjoe.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="UE镜头畸变模拟：OpenCV Lens Distortion"><meta name=twitter:description content="出于仿真的需要，希望在Unreal中能模拟鱼眼镜头的畸变效果，看到UE官方提供了Lens Distortion和OpenCV Lens Distortion两款插件用于模拟镜头畸变，但可惜相关资料不多。UE的博文UE中的相机标定、畸变模拟与矫正 - Unreal Engine做了些介绍，但步骤却又不是很详尽，初学者如我使用时不免多绕了些路，遂写下此文。
插件介绍 这里结合UE中的相机标定、畸变模拟与矫正 - Unreal Engine的介绍，总结如下：
Lens Distortion和OpenCV Lens Distortion用的camera model是一样的，背后的原理也类似。都是根据相机畸变参数生成displacement map，以此模拟镜头畸变 Lens Distortion没有标定功能，且只包含了畸变系数的前几项 Lens Distortion通过shader生成displacement map，而OpenCV Lens Distortion通过OpenCV的API用CPU计算生成，前者效率更快。不过由于displacement map通常只生成一次，这里的效率差异不太重要 补充：什么是displacement map？
A displacement map is a type of texture that is used in 3D computer graphics to create the illusion of depth and detail on a surface without actually changing the geometry of the mesh. A displacement map is typically a grayscale image where the brightness values of each pixel correspond to the amount of displacement that should be applied to the surface at that point."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tanjoe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"UE镜头畸变模拟：OpenCV Lens Distortion","item":"https://tanjoe.github.io/posts/ue%E9%95%9C%E5%A4%B4%E7%95%B8%E5%8F%98%E6%A8%A1%E6%8B%9Fopencv-lens-distortion/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"UE镜头畸变模拟：OpenCV Lens Distortion","name":"UE镜头畸变模拟：OpenCV Lens Distortion","description":"出于仿真的需要，希望在Unreal中能模拟鱼眼镜头的畸变效果，看到UE官方提供了Lens Distortion和OpenCV Lens Distortion两款插件用于模拟镜头畸变，但可惜相关资料不多。UE的博文UE中的相机标定、畸变模拟与矫正 - Unreal Engine做了些介绍，但步骤却又不是很详尽，初学者如我使用时不免多绕了些路，遂写下此文。\n插件介绍 这里结合UE中的相机标定、畸变模拟与矫正 - Unreal Engine的介绍，总结如下：\nLens Distortion和OpenCV Lens Distortion用的camera model是一样的，背后的原理也类似。都是根据相机畸变参数生成displacement map，以此模拟镜头畸变 Lens Distortion没有标定功能，且只包含了畸变系数的前几项 Lens Distortion通过shader生成displacement map，而OpenCV Lens Distortion通过OpenCV的API用CPU计算生成，前者效率更快。不过由于displacement map通常只生成一次，这里的效率差异不太重要 补充：什么是displacement map？\nA displacement map is a type of texture that is used in 3D computer graphics to create the illusion of depth and detail on a surface without actually changing the geometry of the mesh. A displacement map is typically a grayscale image where the brightness values of each pixel correspond to the amount of displacement that should be applied to the surface at that point.","keywords":["Simulation","Unreal","ComputerVision","ComputerGraphics"],"articleBody":"出于仿真的需要，希望在Unreal中能模拟鱼眼镜头的畸变效果，看到UE官方提供了Lens Distortion和OpenCV Lens Distortion两款插件用于模拟镜头畸变，但可惜相关资料不多。UE的博文UE中的相机标定、畸变模拟与矫正 - Unreal Engine做了些介绍，但步骤却又不是很详尽，初学者如我使用时不免多绕了些路，遂写下此文。\n插件介绍 这里结合UE中的相机标定、畸变模拟与矫正 - Unreal Engine的介绍，总结如下：\nLens Distortion和OpenCV Lens Distortion用的camera model是一样的，背后的原理也类似。都是根据相机畸变参数生成displacement map，以此模拟镜头畸变 Lens Distortion没有标定功能，且只包含了畸变系数的前几项 Lens Distortion通过shader生成displacement map，而OpenCV Lens Distortion通过OpenCV的API用CPU计算生成，前者效率更快。不过由于displacement map通常只生成一次，这里的效率差异不太重要 补充：什么是displacement map？\nA displacement map is a type of texture that is used in 3D computer graphics to create the illusion of depth and detail on a surface without actually changing the geometry of the mesh. A displacement map is typically a grayscale image where the brightness values of each pixel correspond to the amount of displacement that should be applied to the surface at that point.\nWhen a displacement map is applied to a mesh in a 3D modeling or animation software, the software uses the brightness values of the displacement map to modify the position of the vertices of the mesh. This creates the illusion of bumps, ridges, and other surface details on the mesh, without actually changing the underlying geometry of the mesh.\nIt’s important to note that the amount of displacement applied to the mesh depends on the intensity of the brightness values in the displacement map, and the software’s settings for how to interpret those values. Different software packages may have different ways of handling displacement maps, so it’s important to consult the documentation or tutorials for your specific software to understand how to use displacement maps effectively.\n步骤 创建工程 启动Unreal Editor，新建“游戏”或“影视与现场活动”的工程，模板选择“空白”即可\n项目设置如下：\n项目创建后，点击编辑器菜单栏“编辑”-\u003e“插件”，在插件对话框中搜素Distortion，启用Lens Distortion和OpenCV Lens Distortion插件，随后重启编辑器：\n创建蓝图类 Lens Distortion和OpenCV Lens Distortion没有提供现成的界面、材质，而是提供了一组蓝图方法。话句话说，这两款插件并不是GUI ready的工具，而是两个library，我们需要自己编写蓝图类，在其中调用它们提供的方法。\n在内容浏览器中，右键-\u003e创建基础资产-\u003e蓝图类：\n父类选择Actor。新建蓝图称之为”DMapCreator“。\n双击新建蓝图，进入蓝图编辑界面\n在左侧”我的蓝图“中，点击”函数\"右侧的“+”按钮，新建一个函数，称之为“CreateDMap”，进入函数蓝图编辑页\n在页面中，点击右键，在弹出菜单中搜索“opencvlens”，点击”创建OpenCVLensDistortionParameters“\n再次右键，选择”Create Undistort UVDisplacement Map“\n从Create Undistort UVDisplacement Map节点的Image Size拖出连接线，选择创建IntPoint\n接下来，新建一个Draw Displacement Map to Render Target节点\n连接节点，并按需填入相机参数：\n在填写相机参数时，注意Fx、Fy、Cx、Cy需要做归一化处理。\n创建Render Target 上一步创建的蓝图中，Draw Displacement Map to Render Target的Output Render Target没有选择资产。我们需要添加一个Render Target，用于保存该节点的输出。\n内容浏览器中，右键-\u003e创建高级资产-\u003e材质和纹理-\u003e渲染目标，命名为”DMapTarget“\n双击打开DMapTarget，调整目标尺寸为相机图片尺寸，这里设置为640x480，格式基于精度考虑使用RGBA32f\n在蓝图编辑器中，将Output Render Target设置为”DMapTarget“：\n我们希望每次点击运行，此蓝图都能被执行，更新displacement map。为此，在“事件图表”中右键，搜索“beginplay”，添加“开始运行”事件\n新建一个CreateDMap节点，将事件连接到它\n现在蓝图类和Render Target都已就绪，可以准备运行，看Render Target是否会被更新了。在运行前，先拖一个DMapCreator到场景中，并保存当前关卡\n随后点击右上角”运行“，如果蓝图执行正常，应当看到DMapTarget的内容由纯黑变为彩色的RGBA图\n如果DMapTarget没有发生变化，可以点击菜单栏“窗口”-\u003e“开发者工具”-\u003e“输出日志”，在日志窗口中查看是否有报错信息\n创建Post Process Material 内容浏览器中，右键新建一个材质，命名为DMapMaterial。打开后，在“细节”-\u003e“材质域\"中，由“表面”切换为“后期处理”\n节点的设置与连接基本参考UE中的相机标定、畸变模拟与矫正 - Unreal Engine而来，这里不再一一说明节点的新建和连接。最终效果是：\n流程的要点概括如下：\nDMapTarget（displacement map）的R、G通道保存畸变矫正的uv offset；B、A通道保存畸变模拟的uv offset 如果ToggleDistortAndUndistort设为1，则Lerp函数输出B、A通道的uv offset，效果是模拟畸变；反之输出R、B通道的uv offset，效果是矫正畸变 如果EnablePP设为1，则Lerp函数会使用输入B，也就是使用偏移过的uv，即启用这个Post Process；反之使用原始的uv，图像保持不变 添加CineCameraActor 现在Post Process Material也已就绪，可以在场景中测试其效果了。\n往场景中添加一个平面Actor（如果你启用了Camera Calibration插件，可以选择添加一个标定板Actor），按需调整其位姿和缩放比\n再拖入一个CineCameraActor，调整其位置，使平面位于视野内\n在“细节”栏里，按需调整相机参数，比如保持聚焦到平面上：\n在后期处理-\u003eRendering Features，设置DMapMaterial为后期处理材质\n可以看到镜头的画面出现了畸变\n补充 注意，不管是Lens Distortion，还是OpenCV Lens Distortion，都只能模拟镜头的畸变，而不能模拟镜头的FOV。如果要仿真广角镜头（如鱼眼），建议通过对cubemap采样的方式来实现。\n参考 UE中的相机标定、畸变模拟与矫正 - Unreal Engine Using Lens Distortion in a CineCamera Actor | 虚幻引擎文档 摄像机镜头校准快速入门指南 | 虚幻引擎文档 ","wordCount":"331","inLanguage":"en","datePublished":"2023-04-28T13:43:06Z","dateModified":"2023-04-28T13:43:06Z","author":{"@type":"Person","name":"Qiao"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tanjoe.github.io/posts/ue%E9%95%9C%E5%A4%B4%E7%95%B8%E5%8F%98%E6%A8%A1%E6%8B%9Fopencv-lens-distortion/"},"publisher":{"@type":"Organization","name":"Qiao","logo":{"@type":"ImageObject","url":"https://tanjoe.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tanjoe.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://tanjoe.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tanjoe.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://tanjoe.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tanjoe.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tanjoe.github.io/posts/>Posts</a></div><h1 class=post-title>UE镜头畸变模拟：OpenCV Lens Distortion</h1><div class=post-meta><span title='2023-04-28 13:43:06 +0000 UTC'>2023-04-28</span>&nbsp;·&nbsp;Qiao</div></header><div class=post-content><p>出于仿真的需要，希望在Unreal中能模拟鱼眼镜头的畸变效果，看到UE官方提供了Lens Distortion和OpenCV Lens Distortion两款插件用于模拟镜头畸变，但可惜相关资料不多。UE的博文<a href=https://www.unrealengine.com/zh-CN/tech-blog/camera-calibration-distortion-simulation-and-correction-in-ue4>UE中的相机标定、畸变模拟与矫正 - Unreal Engine</a>做了些介绍，但步骤却又不是很详尽，初学者如我使用时不免多绕了些路，遂写下此文。</p><h2 id=插件介绍>插件介绍<a hidden class=anchor aria-hidden=true href=#插件介绍>#</a></h2><p>这里结合<a href=https://www.unrealengine.com/zh-CN/tech-blog/camera-calibration-distortion-simulation-and-correction-in-ue4>UE中的相机标定、畸变模拟与矫正 - Unreal Engine</a>的介绍，总结如下：</p><ul><li>Lens Distortion和OpenCV Lens Distortion用的camera model是一样的，背后的原理也类似。都是根据相机畸变参数生成displacement map，以此模拟镜头畸变</li><li>Lens Distortion没有标定功能，且只包含了畸变系数的前几项</li><li>Lens Distortion通过shader生成displacement map，而OpenCV Lens Distortion通过OpenCV的API用CPU计算生成，前者效率更快。不过由于displacement map通常只生成一次，这里的效率差异不太重要</li></ul><p><strong>补充：什么是displacement map？</strong></p><blockquote><p>A displacement map is a type of texture that is used in 3D computer graphics to create the illusion of depth and detail on a surface without actually changing the geometry of the mesh. A displacement map is typically a grayscale image where the brightness values of each pixel correspond to the amount of displacement that should be applied to the surface at that point.</p><p>When a displacement map is applied to a mesh in a 3D modeling or animation software, the software uses the brightness values of the displacement map to modify the position of the vertices of the mesh. This creates the illusion of bumps, ridges, and other surface details on the mesh, without actually changing the underlying geometry of the mesh.</p><p>It&rsquo;s important to note that the amount of displacement applied to the mesh depends on the intensity of the brightness values in the displacement map, and the software&rsquo;s settings for how to interpret those values. Different software packages may have different ways of handling displacement maps, so it&rsquo;s important to consult the documentation or tutorials for your specific software to understand how to use displacement maps effectively.</p></blockquote><h2 id=步骤>步骤<a hidden class=anchor aria-hidden=true href=#步骤>#</a></h2><h3 id=创建工程>创建工程<a hidden class=anchor aria-hidden=true href=#创建工程>#</a></h3><p>启动Unreal Editor，新建“游戏”或“影视与现场活动”的工程，模板选择“空白”即可</p><p><img src=/posts/media/Pasted%20image%2020230428141246.png></p><p><img src=/posts/media/Pasted%20image%2020230428141346.png></p><p>项目设置如下：</p><p><img src=/posts/media/Pasted%20image%2020230428141513.png></p><p>项目创建后，点击编辑器菜单栏“编辑”->“插件”，在插件对话框中搜素Distortion，启用Lens Distortion和OpenCV Lens Distortion插件，随后重启编辑器：</p><p><img src=/posts/media/Pasted%20image%2020230428141847.png></p><h3 id=创建蓝图类>创建蓝图类<a hidden class=anchor aria-hidden=true href=#创建蓝图类>#</a></h3><p>Lens Distortion和OpenCV Lens Distortion没有提供现成的界面、材质，而是提供了一组蓝图方法。话句话说，这两款插件并不是GUI ready的工具，而是两个library，我们需要自己编写蓝图类，在其中调用它们提供的方法。</p><p>在内容浏览器中，右键->创建基础资产->蓝图类：</p><p><img src=/posts/media/Pasted%20image%2020230428143559.png></p><p>父类选择Actor。新建蓝图称之为”DMapCreator“。</p><p>双击新建蓝图，进入蓝图编辑界面</p><p><img src=/posts/media/Pasted%20image%2020230428143850.png></p><p>在左侧”我的蓝图“中，点击”函数"右侧的“+”按钮，新建一个函数，称之为“CreateDMap”，进入函数蓝图编辑页</p><p><img src=/posts/media/Pasted%20image%2020230428144409.png></p><p>在页面中，点击右键，在弹出菜单中搜索“opencvlens”，点击”创建OpenCVLensDistortionParameters“</p><p><img src=/posts/media/Pasted%20image%2020230428144638.png></p><p><img src=/posts/media/Pasted%20image%2020230428144754.png></p><p>再次右键，选择”Create Undistort UVDisplacement Map“</p><p><img src=/posts/media/Pasted%20image%2020230428144853.png></p><p><img src=/posts/media/Pasted%20image%2020230428145128.png></p><p>从Create Undistort UVDisplacement Map节点的Image Size拖出连接线，选择创建IntPoint</p><p><img src=/posts/media/Pasted%20image%2020230428145249.png></p><p><img src=/posts/media/Pasted%20image%2020230428145530.png></p><p>接下来，新建一个Draw Displacement Map to Render Target节点</p><p><img src=/posts/media/Pasted%20image%2020230428145647.png></p><p>连接节点，并按需填入相机参数：</p><p><img src=/posts/media/Pasted%20image%2020230428150047.png></p><p>在填写相机参数时，注意Fx、Fy、Cx、Cy需要做归一化处理。</p><h3 id=创建render-target>创建Render Target<a hidden class=anchor aria-hidden=true href=#创建render-target>#</a></h3><p>上一步创建的蓝图中，Draw Displacement Map to Render Target的Output Render Target没有选择资产。我们需要添加一个Render Target，用于保存该节点的输出。</p><p>内容浏览器中，右键->创建高级资产->材质和纹理->渲染目标，命名为”DMapTarget“</p><p><img src=/posts/media/Pasted%20image%2020230428150746.png></p><p>双击打开DMapTarget，调整目标尺寸为相机图片尺寸，这里设置为640x480，格式基于精度考虑使用RGBA32f</p><p><img src=/posts/media/Pasted%20image%2020230428152651.png></p><p>在蓝图编辑器中，将Output Render Target设置为”DMapTarget“：</p><p><img src=/posts/media/Pasted%20image%2020230428151117.png></p><p>我们希望每次点击运行，此蓝图都能被执行，更新displacement map。为此，在“事件图表”中右键，搜索“beginplay”，添加“开始运行”事件</p><p><img src=/posts/media/Pasted%20image%2020230428151344.png></p><p>新建一个CreateDMap节点，将事件连接到它</p><p><img src=/posts/media/Pasted%20image%2020230428151612.png></p><p>现在蓝图类和Render Target都已就绪，可以准备运行，看Render Target是否会被更新了。在运行前，先拖一个DMapCreator到场景中，并保存当前关卡</p><p><img src=/posts/media/Pasted%20image%2020230428152118.png></p><p>随后点击右上角”运行“，如果蓝图执行正常，应当看到DMapTarget的内容由纯黑变为彩色的RGBA图</p><p><img src=/posts/media/Pasted%20image%2020230428153612.png></p><blockquote><p>如果DMapTarget没有发生变化，可以点击菜单栏“窗口”->“开发者工具”->“输出日志”，在日志窗口中查看是否有报错信息</p></blockquote><h3 id=创建post-process-material>创建Post Process Material<a hidden class=anchor aria-hidden=true href=#创建post-process-material>#</a></h3><p>内容浏览器中，右键新建一个材质，命名为DMapMaterial。打开后，在“细节”->&ldquo;材质域"中，由“表面”切换为“后期处理”</p><p><img src=/posts/media/Pasted%20image%2020230428154104.png></p><p>节点的设置与连接基本参考<a href=https://www.unrealengine.com/zh-CN/tech-blog/camera-calibration-distortion-simulation-and-correction-in-ue4>UE中的相机标定、畸变模拟与矫正 - Unreal Engine</a>而来，这里不再一一说明节点的新建和连接。最终效果是：</p><p><img src=/posts/media/Pasted%20image%2020230428154531.png></p><p>流程的要点概括如下：</p><ul><li>DMapTarget（displacement map）的R、G通道保存畸变矫正的uv offset；B、A通道保存畸变模拟的uv offset</li><li>如果ToggleDistortAndUndistort设为1，则Lerp函数输出B、A通道的uv offset，效果是模拟畸变；反之输出R、B通道的uv offset，效果是矫正畸变</li><li>如果EnablePP设为1，则Lerp函数会使用输入B，也就是使用偏移过的uv，即启用这个Post Process；反之使用原始的uv，图像保持不变</li></ul><h3 id=添加cinecameraactor>添加CineCameraActor<a hidden class=anchor aria-hidden=true href=#添加cinecameraactor>#</a></h3><p>现在Post Process Material也已就绪，可以在场景中测试其效果了。</p><p>往场景中添加一个平面Actor（如果你启用了Camera Calibration插件，可以选择添加一个标定板Actor），按需调整其位姿和缩放比</p><p><img src=/posts/media/Pasted%20image%2020230428160243.png></p><p>再拖入一个CineCameraActor，调整其位置，使平面位于视野内</p><p><img src=/posts/media/Pasted%20image%2020230428160447.png></p><p>在“细节”栏里，按需调整相机参数，比如保持聚焦到平面上：</p><p><img src=/posts/media/Pasted%20image%2020230428160729.png></p><p>在后期处理->Rendering Features，设置DMapMaterial为后期处理材质</p><p><img src=/posts/media/Pasted%20image%2020230428160810.png></p><p>可以看到镜头的画面出现了畸变</p><p><img src=/posts/media/Pasted%20image%2020230428161003.png></p><h2 id=补充>补充<a hidden class=anchor aria-hidden=true href=#补充>#</a></h2><p>注意，不管是Lens Distortion，还是OpenCV Lens Distortion，都只能模拟镜头的畸变，而不能模拟镜头的FOV。如果要仿真广角镜头（如鱼眼），建议通过对cubemap采样的方式来实现。</p><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ul><li><a href=https://www.unrealengine.com/zh-CN/tech-blog/camera-calibration-distortion-simulation-and-correction-in-ue4>UE中的相机标定、畸变模拟与矫正 - Unreal Engine</a></li><li><a href=https://docs.unrealengine.com/4.27/zh-CN/WorkingWithMedia/IntegratingMedia/CameraCalibration/UsingLensDistortioninaCineCameraActor/>Using Lens Distortion in a CineCamera Actor | 虚幻引擎文档</a></li><li><a href=https://docs.unrealengine.com/4.27/zh-CN/WorkingWithMedia/IntegratingMedia/CameraCalibration/CameraCalibrationQuickStartGuide/>摄像机镜头校准快速入门指南 | 虚幻引擎文档</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://tanjoe.github.io/tags/simulation/>Simulation</a></li><li><a href=https://tanjoe.github.io/tags/unreal/>Unreal</a></li><li><a href=https://tanjoe.github.io/tags/computervision/>ComputerVision</a></li><li><a href=https://tanjoe.github.io/tags/computergraphics/>ComputerGraphics</a></li></ul><nav class=paginav><a class=prev href=https://tanjoe.github.io/posts/airsim%E4%B8%AD%E9%92%88%E5%AD%94%E7%9B%B8%E6%9C%BA%E7%95%B8%E5%8F%98%E7%9A%84%E5%AE%9E%E7%8E%B0/><span class=title>« Prev</span><br><span>AirSim中针孔相机畸变的实现</span></a>
<a class=next href=https://tanjoe.github.io/posts/pyside6-%E5%AE%9E%E8%B7%B5/><span class=title>Next »</span><br><span>PySide6 实践</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://tanjoe.github.io/>Qiao</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>