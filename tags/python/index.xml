<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>python on Qiao</title>
    <link>https://tanjoe.github.io/tags/python/</link>
    <description>Recent content in python on Qiao</description>
    <image>
      <title>Qiao</title>
      <url>https://tanjoe.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://tanjoe.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 25 Apr 2023 10:49:46 +0000</lastBuildDate><atom:link href="https://tanjoe.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PySide6 实践</title>
      <link>https://tanjoe.github.io/posts/pyside6-%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Tue, 25 Apr 2023 10:49:46 +0000</pubDate>
      
      <guid>https://tanjoe.github.io/posts/pyside6-%E5%AE%9E%E8%B7%B5/</guid>
      <description>信号槽问题 Python中的任意函数都可以作为槽函数使用而无需使用@Slot装饰器，只要它符合与信号连接的规则(参数对应上)，使用@Slot显示地声明可以提高效率，而不需要Python去隐式地转换类型。
python - Is the PySide Slot Decorator Necessary? - Stack Overflow
另一篇文章Should I decorate slots in Pyside2 and if so how?的回答：
As to whether you should decorate the slots, it&amp;rsquo;s a little trickier to answer &amp;ndash; but generally speaking no, you don&amp;rsquo;t need to.
The only place I know the slot decorator is needed is when a) using threads, as it ensures the decorated method is started in the correct thread, or b) when you want to explicitly map a given slot to a specific call signature (types) in C++.</description>
    </item>
    
    <item>
      <title>mesh里的图着色问题</title>
      <link>https://tanjoe.github.io/posts/mesh%E9%87%8C%E7%9A%84%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 16 Mar 2023 14:21:45 +0000</pubDate>
      
      <guid>https://tanjoe.github.io/posts/mesh%E9%87%8C%E7%9A%84%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/</guid>
      <description>背景 在用trimesh处理模型时，遇到这样一个问题：
给定一个mesh和一张贴图，如何在mesh的每一个face（即每一个三角面片）上贴上此图？
问题 设置贴图关键是设置顶点的uv坐标，最开始的思路是，先设置贴图的4个角落：
uv = np.array([ [0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0], ]) 再建立一个(len(vertices), 2)的numpy数组，遍历时依次填入各角落对应的uv坐标。
这样尝试后，发现mesh的贴图会出现很多奇怪的纹路——这是uv坐标有问题的表现。那问题出现在哪里？
问题在于，mesh的face间会相邻，顶点可能在多个face中存在。因此遍历时，顶点的uv坐标可能覆盖，且同一个face的顶点可能用了相同的uv坐标。这样渲染时就可能是从texture中提取了点或线，而不是提取一个三角面，这些点/线在mesh的face上展开时，就会有异样的纹路。
思路 之前的实现显然少了约束，思考一番后，重新定义问题如下：
给出n个三角形，以及0、1、2、3共四个数，要求每个三角形的顶点都分配一个值，且三角形各个顶点的值不一致。在这些三角形有可能相邻的情况下，如何实现一个分配算法？
拿纸演算了下，发现问题并不太简单。问题的描述又有些冗长，搜索后也没找到思路的火花。抱着试一试的想法，问了下chatGPT，其回答是：
这是一个图着色问题，可以使用图论中的染色算法来解决。
首先，将每个三角形看作一个节点，如果两个三角形有共同的边，则它们之间连一条边。这样得到的图称为三角形图。
对于这个三角形图，可以使用贪心算法来进行染色。具体步骤如下：
将三角形图中的所有节点按照度数从大到小排序。
依次遍历每个节点，将其周围已经染色的节点的颜色从可选颜色列表中删除。
如果所有可选颜色都已经被用过，为当前节点分配一个新的颜色。
继续处理下一个节点，直到所有节点都被染色。
对于本题中的0、1、2、3四个数，可以将它们看作四个颜色，每个三角形的顶点对应一个节点，然后按照上述方法进行染色即可。
需要注意的是，这种染色算法并不能保证一定能够找到一种可行的染色方案。当图中存在奇环（即环的长度为奇数）时，无论使用何种染色算法都无法找到可行的染色方案。因此，在实际应用中，需要对算法进行改进或者针对特定的问题进行分析，以保证能够得到正确的结果。
本来已经做好了chatGPT又会胡诌一番，煞有其事地编出些“算法”。但看到“图着色”的一刻，记忆又涌了上来——我知道它是对的。我怎么会没想到图着色呢？（好吧，图论在工作里遇到的实在太少了）
再复习下图着色：
简述图着色算法的原理与使用 - 掘金
Vertex Coloring &amp;ndash; from Wolfram MathWorld
实现 现在首要问题变成了如何生成vertex的图。查看了下trimesh，颇为惊喜地发现trimesh就带了graph模块，并提供了trimesh.graph.vertex_adjacency_graph 函数，其返回一个networkx.Graph结构。
再看networkx， 和其名称一样，是一个专门做图分析的包。那么应当有对经典着色问题的实现？果真有，Coloring — NetworkX 3.0 documentation
剩下的实现变得颇为简单：
mesh = trimesh.load(&amp;#39;test.obj&amp;#39;) texture = cv2.imread(&amp;#39;test.png&amp;#39;) # 省略其它处理 graph = trimesh.graph.vertex_adjacency_graph(mesh) coloring = nx.coloring.greedy_color(graph, interchange=True) num_colors = max(coloring.</description>
    </item>
    
    <item>
      <title>解决容器内运行conda的GLIBCXX问题</title>
      <link>https://tanjoe.github.io/posts/%E8%A7%A3%E5%86%B3%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%90%E8%A1%8Cconda%E7%9A%84glibcxx%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 03 Jan 2023 17:54:29 +0000</pubDate>
      
      <guid>https://tanjoe.github.io/posts/%E8%A7%A3%E5%86%B3%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%90%E8%A1%8Cconda%E7%9A%84glibcxx%E9%97%AE%E9%A2%98/</guid>
      <description>尝试在容器内运行conda，发现报错如下：
conda &amp;#34;ImportError: /usr/lib/x86_64-linux-gnu/libstdc++.so.6: version `GLIBCXX_3.4.26&amp;#39; not found&amp;#34; 解决方式 安装libgcc
conda install libgcc 如果仍然报错，则
export LD_LIBRARY_PATH=&amp;lt;conda-env-path&amp;gt;/lib:$LD_LIBRARY_PATH conda-env-path替换为conda的目录，核心是通过修改LD_LIBRARY_PATH，让conda的python正确加载conda安装的libstdc++，而非系统的版本
To-Ask 为什么需要配环境变量？
按理来说conda在安装时应当已经修改了bashrc、zshrc等文件，让shell环境里的LD_LIBRARY_PATH带上了conda的lib目录（需要检查下未挂载home目录的容器以确认）。有可能是因为在启动容器时挂载了整个home目录，导致容器内的bash用了host的配置所致。
仔细想想，虽然挂载整个home目录用起来方便，但像shell配置、各类软件的cache本身是应该与host独立的，最好还是挂载home下的特定目录</description>
    </item>
    
  </channel>
</rss>
